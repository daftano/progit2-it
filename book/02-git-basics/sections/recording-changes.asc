=== Salvare le modifiche sul repository

Hai clonato un vero repository Git e hai la copia di lavoro dei file del progetto.
Ora puoi fare qualche modifica e inviare gli snapshots di queste al tuo repository ogni volta che il progetto raggiunga uno stato che vuoi salvare.

Ricorda che ogni file della tua directory di lavoro può stare in uno dei due stati seguenti: *tracked* (tracciato, ndt.) o *untracked* (non tracciato, ndt.).
I file *tracked* sono già presenti nell'ultimo snapshot; possono quindi essere *unmodified* (non modificati, ndt.), *modified* (modificati, ndt.) o *staged*.
I file *untracked* sono tutti gli altri: qualsiasi file nella tua directory di lavoro che non è presente né nell'ultimo snapshot né nella tua area di stage.
Quando cloni per la prima volta un repository, tutti i tuoi file sono tracked e unmodified perché li hai appena prelevati e non hai modificato ancora niente.

Quando editi dei file, Git li vede come modificati, perché sono cambiati rispetto all'ultimo commit.
Metti nell'area di stage i file modificati e poi fai il commit di tutto ciò che è in tale area, il ciclo poi si ripete.

.Il ciclo di vita dello stato dei tuoi file.
image::images/lifecycle.png[The lifecycle of the status of your files.]

[[_checking_status]]
==== Controllo dello stato dei propri file

Lo strumento principale che userai per determinare lo stato dei tuoi file è il comando `git status`.(((git commands, status)))
Se esegui tale comando appena dopo un clone, dovresti vedere qualcosa di simile:

[source,console]
----
$ git status
On branch master
nothing to commit, working directory clean
----

Questo significa che hai una directory di lavoro pulita, in altre parole, nessuno dei file tracciati è stato modificato.
Inoltre Git non ha trovato nessun file non ancora tracciato, altrimenti sarebbero elencati qui.
In aggiunta, il comando indica anche in quale ramo sei informandoti che non differisce dallo stesso ramo sul server.
Per ora, è sempre ``master'', che è il predefinito; non preoccupartene per ora.
<<_git_branching>>  tratterà in dettaglio dei branch (ramificazioni) e dei riferimenti.

Immagina di aver aggiunto un nuovo file al tuo progetto, un semplice file README.
Se il file non esisteva e lanci `git status`, avrai conferma che il file non è tracciato:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Puoi vedere che il nuovo file README non è tracciato, poiché nell'output sta nella sezione dal titolo ``Untracked files''.
`Untracked` significa che Git vede un file che non avevi nello `snapshot` precedente (commit); Git non lo includerà negli snapshot delle tue commit fin quando non glielo dirai esplicitamente.
Fa così per evitare che includa accidentalmente dei file binari generati o qualsiasi altro tipo di file che non intendi includere.
Se vuoi includere il  README, iniziamo a tracciarlo.

[[_tracking_files]]
==== Tracking New Files

Per iniziare a tracciare un nuovo file, si usa il comando `git add`.(((git commands, add)))
Per tracciare il file README, usa questo comando:

[source,console]
----
$ git add README
----

Se lanci nuovamente il comando status, vedrai che il tuo file README ora è tracciato e nell'area di `stage` pronto per il commit:

[source,console]
----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----

Sai che è nell'area di stage perché è nella sezione ``Changes to be committed''.
Se a questo punto fai commit, la versione del file com'era quando hai lanciato `git add` sarà quella che troverai nella cronologia dello snapshot.
Ricorderai che quando prima hai eseguito `git init`, poi hai dovuto lanciare `git add (file)`, per iniziare a tracciare i file nella tua directory.(((git commands, init)))(((git commands, add)))
Il comando `git add` accetta il nome del percorso di un file o una directory; se è una directory, il comando aggiunge ricorsivamente tutti i file in quella directory.

==== Fare lo stage dei file modificati

Modifichiamo un file che è già tracciato.
Se modifichi un file tracciato chiamato ``CONTRIBUTING.md'' e poi esegui il comando `git status`, otterrai qualcosa di simile a:

[source,console]
----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Il file ``CONTRIBUTING.md'' compare nella sezione chiamata ``Changed but not staged for commit'', ovvero che un file tracciato è stato modificato nella directory di lavoro ma non è ancora nello stage.
Per metterlo nello stage, devi eseguire il comando `git add`. `git add` è un comando multifunzione — lo usi per iniziare il tracciamento di nuovi file, per fare lo stage dei file e per fare altre cose, ad esempio per segnare come risolti i conflitti causati da un merge. Può risultare utile immaginare che sia più un ``aggiungi questo contenuto alla prossima commit'' anziché ``aggiungi questo file al progetto''.(((git commands, add)))
Ora si esegue `git add` per mettere in stage il file ``CONTRIBUTING.md'', e si poi esegue ancora `git status`:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Entrambi i file sono nello `stage` e staranno nella prossima commit.
A questo punto, immagina che ti sia ricordato di una piccola modifica da fare in `CONTRIBUTING.md` prima della commit.
Riapri il file e fai la modifica: ora sei pronto per la commit.
Come sempre, esegui  `git status` ancora una volta:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Cos'è successo?
Ora `CONTRIBUTING.md` è elencato _sia_ dentro _che_ fuori lo stage.
Come è possibile?
È saltato fuori che Git ha messo in `stage` il file esattamente com'era quando hai eseguito `git add`.
Se committi ora, la versione di `CONTRIBUTING.md` che verrà committata sarà quella che avevi quando hai eseguito il comando `git add`, non la versione del file che trovi nella directory di lavoro quando esegui `git commit`.
Se modifichi un file dopo che hai eseguito `git add`, devi rieseguire `git add` per mettere nello `stage` l'ultima versione del file:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Stato abbreviato

L'output di `git status` oltre ad essere abbastanza completo, è anche nolto prolisso. Git ha anche un flag per abbreviare, in modo che si possano vedere i cambiamenti in una forma più compatta. Se si esegue `git status -s` o `git status --short` si ottiene un output del comando molto più semplice.

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

I nuovi file che non sono tracciati sono segnati con `??`, i nuovi file che sono stati aggiunti nell'area di stage hanno una `A`, quelli modificati hanno una `M` e così via. Ci sono due colonne nell'output - la colonna di sinistra indica che il file è nello stage e quella di destra indica che è stato modificato.  In questo output, per esempio, il file `README` è modificato nella directory di lavoro ma non ancora nello stage, mentre il file `lib/simplegit.rb` è modificato e nello stage. `Rakefile` è stato modificato, posto nello stage e poi di nuovo modificato, quindi ci sono delle modifiche sia nello stage che fuori.

[[_ignoring]]
==== Ignorare i file

Spesso hai dei file che non vuoi che Git aggiunga automaticamente e nemmeno che te li mostri come non tracciati.
Generalmente si tratta di file generati automaticamente, come i log o quelli prodotti dal tuoi sistema di `build`.
In questi casi puoi creare un file chiamato `.gitignore` con la lista dei pattern dei file che vuoi ignorare..(((ignoring files)))
Ecco un esempio di file `.gitignore`:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

La prima riga dice a Git di ignorare qualsiasi file che finisca con ``.o'' or ``.a'' – file di oggetti o archivi che possono essere il prodotto di una compilazione.
La seconda riga dice a Git di ignorare tutti i file che finiscono con tilde (`~`), che è usata da alcuni editor di testo come Emacs per marcare i file temporanei.
Puoi anche includere una directory log, tmp, o pid; documenti generati automaticamente e così via.
È buona norma Definire un file `.gitignore` prima di iniziare, così eviti il rischio di committare accidentalmente dei file che non vuoi nel tuo repository Git.

Queste sono le regole per i pattern che puoi usare in `.gitignore`:

*  Le righe vuote o quelle che iniziano con `#` vengono ignorate.
*  Funzionano gli standard `glob pattern` (http://it.wikipedia.org/wiki/Glob_pattern, ndt).
*  Puoi terminare i pattern con uno slash (`/`) per indicare una directory.
*  Puoi negare un pattern facendolo iniziare con un punto esclamativo (`!`).

I `glob pattern` sono come espressioni regolari semplificate, usate dalla shell.
Un asterisco (`*`) corrisponde a zero o più caratteri; `[abc]` corrisponde a ogni carattere all'interno delle parentesi (in questo caso a, b, o c); il punto interrogativo (`?`) corrisponde ad un carattere singolo; e i caratteri all'interno delle parentesi quadre separati dal segno meno (`[0-9]`)  corrispondono ad ogni carattere all'interno dell'intervallo (in questo caso da 0 a 9).
Si possono usare due asterischi cui corrispondono directory nidificate; `a/**/z` corrisponde ad `a/z`, `a/b/z`, `a/b/c/z`, e così via.

Ecco un altro esempio di file .gitignore:

[source]
----
# nessun file .a
*.a

# ma traccia lib.a, pur continuando ad ignorare i file .a di prima
!lib.a

# ignora il solo file TODO nella root, non quello in subdir/TODO
/TODO

# ignora tutti i file nella directory build/
build/

# ignora doc/notes.txt, ma non doc/server/arch.txt
doc/*.txt

# ignora tutti i file .txt nella directory doc/ 
doc/**/*.txt
----

[TIP]
====
Come punto di partenza per il tuo progetto, GitHub manutiene un elenco abbastanza completo di esempi di file `.gitignore` per dozzine di progetti e linguaggi sul sito https://github.com/github/gitignore[].
====

[[_git_diff_staged]]
==== Mostra le modifiche dentro e fuori lo stage

Se il comando `git status` ti risulta troppo vago —vuoi sapere cos'è stato effettivamente modificato e non solo quali file— puoi usare il comando `git diff`.(((git commands, diff)))
Tratteremo `git diff` in seguito più in dettaglio, ma probabilmente lo userai molto spesso per rispondere a queste due domande: Cos'è che hai modificato ma non è ancora instage?
E cos'hai nello `stage` che non sia stato ancora committato?
Sebbene `git status` risponda a queste domande in modo generico elencando i nomi dei file, `git diff` mostra le righe effettivamente aggiunte o rimosse —la patch, così com'è.

Supponiamo che tu abbia modificato nuovamente i file `README` e `CONTRIBUTING.md` ma messo nello `stage` solo il primo.
Se esegui il comando `git status`, vedrai qualcosa del genere:

[source,console]
----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Per vedere cosa hai modificato, ma non ancora messo nello stage, digita `git diff` senza altri argomenti:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.
 
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Questo comando confronta cosa c'è nella tua directory di lavoro con quello che c'è nella tua area di `stage`.
Il risultato mostra le tue modifiche che ancora non hai messo nello `stage`.

Se vuoi vedere cosa c'è nello `stage` e che farà parte della prossima commit, puoi usare `git diff --staged`.
Questo comando confronta le modifiche nello `stage` all'ultima commit.

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

È importante notare che `git diff` di per sé non visualizza tutte le modifiche fatte dall'ultima commit, ma solo quelle non ancora nello `stage`.
Questo può confondere, perché se hai messo in `stage` tutte le tue modifiche, `git diff` non mostrerà nulla.

Ecco un altro esempio, se metti in `stage` il file  `CONTRIBUTING.md` e lo modifichi, puoi usare `git diff` per vedere quali modifiche al file sono in stage e i quali non ancora: Supponiamo che l'ambiente appaia come questo:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo 'test line' >> CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Puoi quindi usare `git diff` per vedere cosa non è ancora in `stage`

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects
 
 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

e `git diff --cached` per vedere cos'è già in stage  (--staged e --cached sono sinonimi):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.
 
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
[[_git_difftool]]
.Git Diff in an External Tool
====
We will continue to use the `git diff` command in various ways throughout the rest of the book. C'è un altro modo di vedere queste differenze se invece si preferisce un programma grafico o uno esterno. Se si esegue `git difftool` anziché `git diff`, si può visualizzare le differenze in software come Araxis, emerge, vimdiff ed altri. Si esegua `git difftool --tool-help` per vedere quelli disponibili sul proprio sistema.
====

[[_committing_changes]]
==== Committare le modifiche

Ora che la tua area di stage è configurata come vuoi, puoi fare la commit delle tue modifiche.
Ricorda che tutto ciò che non è in `stage` —qualsiasi file che hai creato o modificato per cui, in seguito, non hai fatto `git add`— non andrà nella commit.
Rimarranno come file modificati sul tuo disco.
In questo caso, mettiamo che l'ultima volta che hai eseguito `git status`, hai visto che tutto era in `stage`, così sei pronto a committare le tue modifiche.(((git commands, status)))
Il modo più semplice per eseguire il commit consiste nel digitare `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Facendolo lanci il tuo editor predefinito.
(Questo è impostato nella tua shell con la variabile di ambiente `$EDITOR` – generalmente vim o emacs, sebbene lo si possa configure con qualsiasi altro editor, usando il comando `git config --global core.editor` come hai visto in <<_getting_started>>).(((editor, changing default)))(((git commands, config)))

L'editor visualizzerà il testo (questo è un esempio della schermata di Vim):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

Come vedi, il messaggio predefinito della commit contiene l'ultimo output del comando `git status`, commentato, e la prima riga in alto è vuota.
Puoi rimuovere questi commenti e inserire il tuo messaggio di commit, o puoi lasciarli così come sono per ricordare cosa stai committando.
(Per un'annotazione ancora più esplicita sulle modifiche effettuate puoi usare l'opzione `-v` a `git commit`.
Facendo ciò, verranno inserite nel commento anche le modifiche stesse, così che tu possa vedere esattamente cosa hai fatto). Quando esci dall'editor, Git crea il tuo commit quel messaggio (rimuovendo commenti ed eventuali diff).

In alternativa, puoi inserire il messaggio per la tua commit sulla stessa riga di comando della `commit` specificando l'opzione -m, come segue:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Now you've created your first commit!
Puoi vedere che la commit restituisce alcune informazioni su se stessa: su quale `branch` (ramo, ndt) hai fatto la commit (`master`), quale checksum SHA-1 ha la commit (`463dc4f`), quanti file sono stati modificati e le statistiche sulle righe aggiunte e rimosse con la commit.

Ricorda che la commit registra lo snapshot che hai salvato nella tua area di `stage`.
Qualsiasi cosa che non è nello `stage` rimarrà lì come modificata; puoi fare un'altra commit per aggiungerli alla cronologia del progetto.
Ogni volta che fai una commit, stai salvando un'istantanea (`snapshot`) del tuo progetto che puoi ripristinare o confrontare in seguito.

==== Saltare l'area di stage

(((staging area, skipping)))
Sebbene sia estremamente utile per amministrare le commit come desiderato, l'area di stage è talvolta più complessa del necessario nel lavoro normale.
Se vuoi saltare l'area di `stage`, Git fornisce una semplice scorciatoia.
Aggiungendo l'opzione `-a` al comando `git commit`, Git, committando, mette automaticamente nello `stage` tutti i file che erano già tracciati, permettendoti di saltare la parte `git add`:

[source,console]
----
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Notice how you don't have to run `git add` on the ``CONTRIBUTING.md'' file in this case before you commit.

[[_removing_files]]
==== Removing Files

(((files, removing)))
Per rimuovere un file da Git, devi rimuoverlo dai file tracciati (più precisamente,  rimuoverlo dall'area di `stage`) e quindi committare.
Il comando `git rm` fa questo e rimuove anche il file dalla tua directory di lavoro, così che la prossima volta non lo vedrai come un file non tracciato.

Se rimuovi semplicemente il file dalla directory di lavoro, apparirà nella sezione  ``Changed but not updated'' (cioè, _non in `stage`_) dell'output di `git status`:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Quindi, eseguendo `git rm`, si mette nello stage la rimozione del file:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

La prossima volta che committerai, il file sparirà e non sarà più tracciato.
Se avevi già modificato il file e lo avevi aggiunto all'indice, devi forzarne la rimozione con l'opzione `-f`.
Questa è una misura di sicurezza per prevenire la rimozione accidentale dei dati che non sono ancora stati salvati in uno `snapshot` e che non possono essere recuperati con Git.

Un'altra cosa utile che potresti voler fare è mantenere il file nel tuo ambiente di di lavoro ma rimuoverlo dall'area di `stage`.
In altre parole, vuoi mantenere il file sul tuo disco ma non vuoi che Git continui a tracciarlo.
Questo è particolarmente utile se hai dimenticato di aggiungere qualcosa al tuo `.gitignore` e accidentalmente lo metti in `stage`, come un file di log molto grande o un gruppo di file compilati `.a`.
Per farlo usa l'opzione `--cached`:

[source,console]
----
$ git rm --cached README
----

Puoi passare file, directory o pattern glob di file al comando `git rm`.
Questo significa che puoi fare

[source,console]
----
$ git rm log/\*.log
----

Nota la barra inversa (`\`) prima di `*`.
Questo è necessario perché Git ha una paropria modalità di espansione dei nomi dei file in aggiunta a quella della tua shell.
Questo comando rimuove tutti i file che hanno l'estensione `.log` nella directory `log/`.
O puoi eseguire:

[source,console]
----
$ git rm \*~
----

Per rimuovere tutti i file che finiscono con `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Unlike many other VCS systems, Git doesn't explicitly track file movement.
Se rinomini un file in Git, nessun metadato viene salvato per dirgli che lo hai rinominato.
Tuttavia, Git è abbastanza intelligente da capirlo dopo che l'hai fatto — più in la ci occuperemo di rilevare lo spostamento dei file.

Può perciò creare un po' di confusione il fatto che Git abbia un comando `mv`.
Se vuoi rinominare un file in Git puoi eseguire qualcosa come

[source,console]
----
$ git mv file_from file_to
----

e funziona.
Se, infatti, lanci un comando del genere e controlli lo stato, vedrai che Git considera il file rinominato:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

Ovviamente, questo è equivalente a eseguire:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git capisce che, implicitamente stai rinominando il file, quindi non c'è differenza se rinomini un file in questo modo o col comando `mv`.
L'unica vera differenza è che `mv` è comando solo anziché tre: è un questione di convenienza.
La cosa più importante è che puoi usare qualsiasi strumento per rinominare un file, e gestire l'aggiunta/rimozione più tardi, prima della commit.
