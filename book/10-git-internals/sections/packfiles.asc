=== Packfile

Torniamo agli oggetti del database per il repository Git di test.
A questo punto ci sono 11 oggetti: 4 blob, 3 alberi (tree), 3 commit, e 1 tag:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Git comprime il contenuto di questi pochi file con zlib, complessivamente occupano solo 925 byte.
Aggiungeremo al repository del contenuto più voluminoso per mostrare un'interessante caratteristica di Git.
A titolo dimostrativo, aggiungeremo il file `repo.rb` dalla libreria Grit, che è un file di codice sorgente di circa 22K:

[source,console]
----
$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb > repo.rb
$ git add repo.rb
$ git commit -m 'added repo.rb'
[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)
----

Osservando l'albero dopo questa nuova commit, si vedrà l'hash SHA-1 dell'oggetto blob per repo.rb:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Si può quindi usare `git cat-file` per vedere quanto sia grande quest'oggetto:

[source,console]
----
$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044
----

Si modifica un po’ il file e si vede cosa succede:

[source,console]
----
$ echo '# testing' >> repo.rb
$ git commit -am 'modified repo a bit'
[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)
----

Controllando l'albero risultate da questa commit si vedrà qualcosa di interessante:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Il blob è ora un blob diverso, cioè, nonostante sia stata aggiunta una sola riga alla fine del file da 400 righe, Git memorizza il nuovo contenuto come un oggetto completamente nuovo:

[source,console]
----
$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054
----

Ora, sul disco, ci sono due oggetti quasi identici da 22K.
Non sarebbe carino se Git potesse memorizzarne solo uno per intero e del secondo solo la differenza col primo?

In effetti può farlo.
Il formato iniziale con cui Git salva gli oggetti sul disco è detto formato ``sciolto'' (*loose*).
Però, occasionalmente, Git impacchetta molti di questi oggetti in un singolo file binario, chiamato ``packfile'', per risparmiare spazio ed essere più efficiente.
Git lo fa se ci sono molti oggetti sciolti in giro, eseguendo il comando `git gc` o se eseguendo una  push verso un server remoto.
Lo si può fare manualmente, per vedere cosa succede, eseguendo il comando `git gc`, che forza Git a comprimere gli oggetti:

[source,console]
----
$ git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)
----

Guardando la directory degli oggetti, si troverà che molti oggetti sono scomparsi, ma ne sono apparsi un paio nuovi:

[source,console]
----
$ find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
----

Gli oggetti rimanenti sono i blob che non sono puntati da nessuna commit: in questo caso i blob di esempio ``what is up, doc?'' e ``test content'' creati precedentemente.
Poiché non sono stati ancora aggiunti a nessuna commit, vengono considerati 'appesi' (*dangling*) e non vengono impacchettati nel nuovo packfile.

Gli altri file sono il nuovo packfile ed un indice.
Il packfile è un singolo file contenente tutti gli altri oggetti rimossi dal filesystem.
L'indice è un file che contiene gli offset degli oggetti contenuti nel packfile per recuperare velocemente il singolo oggetto.
La cosa interessante è che, sebbene gli oggetti occupassero in totale 22K sul disco prima dell'esecuzione di `gc`, il nuovo packfile è di soli 7K.
Lo spazio usato sul disco si è ridotto ai ⅔ comprimendo gli oggetti.

Git come ci riesce?
Quando Git comprime gli oggetti, cerca prima i file che hanno nome e dimensioni simili, e memorizza solo le differenze fra una versione e la successiva.
Si può guardare dentro il pacchetto e vedere cosa ha fatto Git per risparmiare spazio.
Il comando *plumbing* `git verify-pack` consente di vedere cos'è stato impacchettato:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
----

Qui, il blob `033b4`, che, si ricorderà, è la prima versione del file repo.rb, fa riferimento al blob `b042a`, che era la seconda versione del file.
La terza colonna indica la dimensione degli oggetti nel pacchetto, e si vede che `b042a` occupa 22K del file, ma `033b4` solo 9 byte.
Un'altra cosa interessante è che è la seconda versione del file ad essere stata memorizzata intatta, mentre della versione originale c'è solo il delta: questo perché è molto più probabile che si abbia bisogno di un accesso veloce alla versione più recente del file.

La cosa ancora più interessante è che può essere re-impacchettato in qualsiasi momento.
Git, a volte, re-impacchetta automaticamente il database cercando sempre di risparmiare spazio; lo si può fare anche a mano, in qualsiasi momento, eseguendo il comando `git gc`.
