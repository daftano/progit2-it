=== Manutenzione e recupero dei dati

A volte può essere necessario fare un po’ di pulizia nel repository per renderlo più compatto, per ripulire un repository importato o per recuperare del lavoro perso.
Questa sezione tratta alcuni di questi scenari.

[[_git_gc]]
==== Manutenzione

Git, occasionalmente, esegue automaticamente il comando ``auto gc''.
Il più delle volte questo comando non fa niente.
Se però ci sono troppi oggetti sparpagliati (oggetti che non sono racchiusi in un packfile) o troppi packfile, Git esegue esplicitamente un `git gc`.
``gc'' sta per 'garbage collect', e il comando fa diverse cose: raccoglie tutti gli oggetti sparsi e li riunisce in packfile, consolida i packfile in uno packfile più grande e rimuove gli oggetti che non sono raggiungibili da alcuna commit e che sono più vecchi di qualche mese.

Il comando “auto gc” si può eseguire manualmente così:

[source,console]
----
$ git gc --auto
----

Questo, lo ripetiamo, generalmente non farà niente.
Ci dovranno essere almeno 7.000 oggetti sciolti o più di 50 pacchetti perché Git esegua la 'garbage collection' vera e propria.
Questi limiti sono modificabili cambiando rispettivamente, i valori di `gc.auto` e `gc.autopacklimit` della configurazione.

Un’altra cosa che fa `gc` è quella di impacchettare i riferimenti in un singolo file.
Supponiamo che il repository contenga i branch e i tag seguenti:

[source,console]
----
$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1
----

Eseguendo `git gc`, non si avranno più questi file nella directory `refs`.
Git li sposterà, per efficienza, in un file chiamato `.git/packed-refs`, che apparirà così:

[source,console]
----
$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9
----

Se si aggiorna un riferimento, Git non modifica questo file, ma scrive un nuovo file nella directory `refs/heads`.
Per conoscere lo SHA di uno specifico riferimento, Git controlla se sta nella directory `refs` e, se non lo trova, nel file `packed-refs`.
In ogni caso, se non si trova un riferimento nella directory `refs`, questo sarà probabilmente nel file `packed-refs`.

Si noti che l'ultima riga del file inizia con un `^`.
Questo indica che il tag immediatamente precedente è un tag annotato e che quella riga è la commit a cui punta il tag annotato.

[[_data_recovery]]
==== Recupero dei dati

Durante il lavoro quotidiano può capitare che, accidentalmente, si perda una commit.
Questo generalmente succede quando si forza la cancellazione di un branch per poi scoprire di averne ancora bisogno, o quando si fa un hard-reset di un branch, abbandonando quindi delle commit da cui poi si vorrà recuperare qualcosa.
Ipotizzando che sia successo proprio questo: come si fa a ripristinare le commit perse?

Questo è un esempio di un hard-reset del branch master nel repository di test su commit più vecchia e il successivo recupero delle commit perse.
Prima di tutto si controlla la posizione del proprio repository:

[source,console]
----
$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Ora, si riporta il branch `master` alla commit centrale:

[source,console]
----
$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

In questo modo si sono perse le due commit più in alto: non c'è alcun branch dal quale si arriva a quelle commit.
Si deve scoprire lo SHA dell'ultima commit e poi aggiungere un branch che vi punti.
Il trucco consiste nel trovare lo SHA dell'ultima commit: non è come la si ricordava, vero?

Spesso il modo più veloce è usare `git reflog`.
Mentre si lavora, Git memorizza silenziosamente lo stato dell'HEAD man mano che lo si cambia.
Il reflog viene aggiornato ogni volta che si fa una commit o si cambia branch.
Il reflog viene aggiornato anche dal comando `git update-ref`, che è un buon motivo per usarlo, invece di scrivere direttamente il valore dello SHA nei  file ref, come visto nella sezione <<_git_refs>>.
In qualsiasi momento si vedere dove si è stati, eseguendo il comando`git reflog`:

[source,console]
----
$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb
----

Qui vediamo le due commit di cui abbiamo fatto il checkout, non ci sono poi tante informazioni.
Per vedere le stesse informazioni, ma in una maniera più utile, possiamo eseguire il comando `git log -g`, che restituisce un normale output  del reflog.

[source,console]
----
$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit
----

Si vede che una delle commit perse è quella in fondo, la si può recuperare creando un nuovo branch a questa commit.
Per esempio, si può creare un branch chiamandolo `recover-branch` a quella commit (ab1afef):

[source,console]
----
$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Bene! Ora pare che si abbia un branch chiamato `recover-branch` dove prima c'era il branch `master`, rendendo i primi due commit di nuovo raggiungibili.
Supponiamo, ora, che per qualche ragione la perdita non stia nel in reflog: lo si può simulare rimuovendo `recover-branch` e cancellando il reflog.
Ora le due commit non sono più raggiungibili:

[source,console]
----
$ git branch -D recover-branch
$ rm -Rf .git/logs/
----

Dato che i dati del reflog sono conservati nella directory `.git/logs/`, non c'è alcun reflog.
A questo punto come possiamo recuperare quella commit?
Uno dei modi è usare l’utility `git fsck`, che verificherà l'integrità del database.
Eseguendola con l'opzione `--full`, l'utility mostrerà tutti gli oggetti che non sono puntati da alcun altro oggetto:

[source,console]
----
$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
----

In questo caso, ritroviamo la commit scomparsa dopo la stringa ``dangling commit''.
La si può recuperare allo stesso modo, aggiungendo un branch che punti al suo SHA.

[[_removing_objects]]
==== Rimozione di oggetti

Ci sono un sacco di grandi cose in Git, ma una delle caratteristiche che può creare qualche problema è che la `git clone` scarica l'intera storia di un progetto, con tutte le versioni di tutti i file.
Questo va bene se sono tutti codici sorgenti perché Git è super ottimizzato per comprimere questi dati in modo efficiente.
Se però qualcuno, ad un certo punto, ha aggiunto un solo, enorme file, ogni clone scaricherà quel file, anche se poi quel file è stato cancellato dal progetto in una commit subito dopo.
Poiché è raggiungibile nella cronologia, resterà sempre lì.

Questo può rappresentare un grosso problema nella conversione di repository Subversion o Perforce in Git.
Perché in quei sistemi non si scarica l'intera cronologia, e questo tipo inserimenti ha conseguenze minime.
In caso di import da un altro sistema o se ci si rende conto che il repository è più grande del dovuto, vediamo come trovare e rimuovere questi oggetti di grandi dimensioni.

*Attenzione: questa tecnica è distruttiva per la cronologia dei commit.*
Riscrive ogni oggetto commit a partire dal primissimo albero che si modifica per rimuovere il riferimento a quel file.
Se lo si fa subito dopo una importazione, prima che chiunque inizi a riferirsi alla commit, non c'è nessun problema, altrimenti si dovranno avvisare tutti i collaboratori perché effettuino il rebase del loro lavoro sulle nuove commit.

Come dimostrazioni si aggiungerà un grande file nel repository di test, lo si rimuoverà nella commit successiva, lo si cercherà e rimuoverà permanentemente dal repository.
Prima di tutto si aggiunge un grosso file alla cronologia del repository:

[source,console]
----
$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz > git.tgz
$ git add git.tgz
$ git commit -m 'add git tarball'
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz
----

Oops — non si voleva aggiungere questo archivio così grande al progetto.
Meglio rimediare:

[source,console]
----
$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'oops - removed large tarball'
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz
----

Ora si esegue il `gc` sul database e e si controlla lo spazio utilizzato:

[source,console]
----
$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)
----

Si può lanciare anche il comando `count-objects` per vedere lo spazio in uso::

[source,console]
----
$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0
----

Il valore di `size-pack` è la dimensione del packfile in kilobyte e quindi si stanno usando 5MB.
Prima dell'ultima commit, si impiegavano circa 2K – chiaramente, la rimozione de file con la commit precedente non lo rimuove dallo storico.
Ogni volta che qualcuno clonerà questo repository, dovrà scaricare tutti i 5MB solo avere questo progettino, solamente perché è stato aggiunto per errore questo file enorme.
Sbarazziamocene.

Prima di tutto lo si deve trovare.
In questo caso già sappiamo quale sia.
Ma supponiamo di non saperlo: come possiamo identificare il file o i file che occupano tanto spazio?
Eseguendo `git gc`, tutti gli oggetti staranno in un packfile e gli oggetti più grandi si possono identificare eseguendo un altro comando *plumbing*, `git verify-pack`, e ordinando secondo il terzo campo dell'output, che indica la dimensione.
Si può anche effettuare una *pipe* con `tail` dato che ci interessano solo gli ultimi file, quelli più grandi:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438
----

L'oggetto grande è in fondo alla lista: 5MB.
Per scoprire di quale file si tratti useremo il comando `rev-list`, che abbiamo già visto rapidamente nel Capitolo <<_enforcing_commit_message_format>>.
Usando l’opzione `--objects` con `rev-list`, questi elencherà tutti gli SHA delle commit nonché gli SHA dei blob col relativo path dei file.
Lo si usa per cercare il nome del blob:

[source,console]
----
$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz
----

Ora dobbiamo rimuovere questo file da tutti gli alberi della cronologia.
Si vedono facilmente quali commit hanno modificato questo file:

[source,console]
----
$ git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball
----

Si devono riscrivere tutte le commit successive alla `7b30847` per rimuovere totalmente questo file dalla cronologia di Git.
Per farlo useremo `filter-branch`, usato nel Capitolo <<_rewriting_history>>:

[source,console]
----
$ git filter-branch --index-filter \
  'git rm --cached --ignore-unmatch git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten
----

L'opzione `--index-filter` e simile alla `--tree-filter` usata nel Capitolo <<_rewriting_history>>, ad eccezione del fatto che invece di passare un comando che modifichi i file estratti [checked out, Ndt.] sul disco, si sta ogni volta modificando la propria area di stage e l’indice.

Piuttosto che rimuovere un file con `rm file`, lo si deve rimuovere con `git rm --cached`: lo si deve rimuovere dall'indice, non dal disco.
Il motivo per farlo in questo modo è una questione di velocità perché Git non deve fare il checkout di ciascuna versione sul disco prima di eseguire il filtro, e quindi tutto il processo è molto più rapido.
Si ha lo stesso risultato con `--tree-filter`.
L’opzione `--ignore-unmatch` di `git rm` serve a far sì che non venga generato un errore se il file che si stà cercando di eliminare non c'è in quella versione.
In ultimo, si dovrebbe chiedere a `filter-branch` di riscrivere la cronologia solo a partire dalla commit `7b30847` in poi, dato che si sa che è da lì che sono cominciati i problemi.
In caso contrario inizierebbe dall'inizio e sarebbe inutilmente più lento.

Nella cronologia ora c'è più alcun riferimento a quel file.
Ma vi fanno riferimento il reflog e un nuovo gruppo di riferimenti che Git ha aggiunto quando è stato lanciato `filter-branch` in `.git/refs/original`, e quindi si devono rimuovere anche questi e ricompattare il database.
Si deve correggere qualsiasi cosa che ancora punti a quelle vecchie commit, prima di ricompattare il repository:

[source,console]
----
$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)
----

Vediamo ora lo spazio recuperato.

[source,console]
----
$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----

Le dimensioni del repository compresso è scesa a 8K, che è molto meglio dei 5MB precedenti.
Dalle dimensioni si vede che l'oggetto è ancora presente tra quelli sparsi, quindi non è ancora sparito, ma non verrà più trasferito quando si farà una push o se qualcun altro farà un clone, che è la cosa più importante.
Volendo eliminare definitivamente l'oggetto, si potrà eseguire il comando `git prune --expire`.

[source,console]
----
$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----
