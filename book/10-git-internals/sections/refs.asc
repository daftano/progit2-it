[[_git_refs]]
=== Riferimenti di Git

Per vedere l'intera cronologia, si può eseguire un comando come `git log 1a410e`, ma si deve tener presente che quel `1a410e`, è l'ultima commit nel percorrere lo storico alla ricerca di tutti gli oggetti.
C'è bisogno di un file in cui memorizzare il valore dello SHA-1 attribuendogli un nome semplice in modo da poterlo usare invece del valore dello SHA-1.

In Git si chiamano "riferimenti" o "refs”: questi file contenenti i valori hash SHA-1 si trovano nella directory `.git/refs`.
Nel nostro progetto questa directory non contiene file ma una semplice struttura:

[source,console]
----
$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
----

Per creare un nuovo riferimento che aiuterà a ricordare dov'è l'ultima commit, si potrebbe, tecnicamente, fare semplicemente qualcosa del genere:

[source,console]
----
$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" > .git/refs/heads/master
----

Il riferimento appena creato si può ad usare al posto del valore SHA-1 nei comandi Git:

[source,console]
----
$ git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Si sconsiglia di modificare direttamente i file di riferimento.
Se si deve aggiornare un riferimento, Git fornisce un comando sicuro chiamato `update-ref`:

[source,console]
----
$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
----

Questo è fondamentalmente un branch in Git: un semplice puntatore o riferimento all'*head* di un flusso di lavoro.
Per creare un branch dalla seconda commit, si può fare questo:

[source,console]
----
$ git update-ref refs/heads/test cac0ca
----

Il branch conterrà solo il lavoro da quella commit in poi:

[source,console]
----
$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Ora, il database Git assomiglia concettualmente a questo.

.Gli oggetti directory Git con inclusi i riferimenti all'head del branch.
image::images/data-model-4.png[Git directory objects with branch head references included.]

Quando si eseguono comandi come `git branch (branchname)`, Git in realtà esegue il comando `update-ref` per aggiungere lo SHA-1 dell'ultima commit del branch in cui si è, in qualsiasi nuovo riferimento si vada a creare.

[[_the_head]]
==== HEAD

La questione ora è questa: eseguendo `git branch (branchname)`, come fa Git a conoscere lo SHA-1 dell'ultima commit?
La risposta è nel file HEAD.

Il file HEAD è un riferimento simbolico al branch corrente.
Per riferimento simbolico si intende che, a differenza di un normale riferimento, esso non contiene un valore SHA-1 ma un puntatore a un altro riferimento.
Esaminando il file, di norma si vedrà qualcosa del genere:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/master
----

Eseguendo `git checkout test`, Git aggiorna il file cambiandolo così:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/test
----

L'esecuzione di `git commit`, crea l'oggetto commit il cui genitore sia qualsiasi SHA-1 a cui faccia riferimento l'HEAD.

Si può modificare manualmente questo file, ma, di nuovo, esiste un comando più sicuro per farlo: `symbolic-ref`.
Con questo comando si può leggere il valore proprio HEAD:

[source,console]
----
$ git symbolic-ref HEAD
refs/heads/master
----

Si può anche impostare il valore di HEAD:

[source,console]
----
$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
----

Non può impostare un riferimento simbolico al di fuori di refs:

[source,console]
----
$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
----

==== I tag

Questi sono i tre principali tipi di oggetti in Git, ma ce n'è un quarto.
L'oggetto tag è molto simile a un oggetto commit: contiene un'etichetta, una data, un messaggio ed un puntatore.
La differenza principale sta nel fatto che un oggetto tag punta in genere a una commit piuttosto che a un albero.
È come un riferimento a un branch, ma non si sposta mai: punta sempre alla stessa commit ma le da un nome più semplice.

Come visto nel Capitolo <<_git_basics_chapter>>, ci sono due tipi di tag: annotato (*annotated*) e leggero (*lightweight*).
Un tag *lightweight* si crea eseguendo un comando come questo:

[source,console]
----
$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
----

Questo è tutto: un tag *lightweight* è riferimento che non cambia mai.
Un tag annotato è più complesso.
Per un tag annotato, Git crea un oggetto tag e scrive un riferimento che punta ad esso anziché puntare direttamente alla commit.
Lo si può vedere creando un tag annotato (`-a` indica per indicare un tag annotato):

[source,console]
----
$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
----

Questo è il valore SHA-1 dell'oggetto creato:

[source,console]
----
$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
----

Ora, si esegue il comando `cat-file` su questo hash SHA-1:

[source,console]
----
$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

test tag
----

Si noterà che l'oggetto punta all’hash SHA-1 della commit che taggata.
Si noti anche che non è necessario puntare ad una commit: si può taggare qualsiasi oggetto Git.
Nei sorgenti di Git, per esempio, il manutentore ha aggiunto la sua chiave pubblica GPG come oggetto blob e lo ha taggato.
La chiave pubblica si può vedere eseguendo questo in un clone di un repository Git:

[source,console]
----
$ git cat-file blob junio-gpg-pub
----

Anche il repository del kernel di Linux ha un oggetto tag che non punta ad una commit: il primo tag creato punta all'albero iniziale dell'import del codice sorgente.

==== Riferimenti remoti

Il terzo tipo di riferimento che vedremo è il riferimento remoto.
Se si aggiunge un repository remoto e vi si aggiorna qualcosa con *push*, Git salva il valore del quale si è fatto il push, per ogni branch, nella directory `refs/remotes`.
Per esempio si può aggiungere un repository remoto chiamato `origin`e farvi il push del proprio branch `master`:

[source,console]
----
$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -> master
----

Si potrà vedere qual era il branch `master` del repository remoto `origin` dall'ultima comunicazione col server esaminando il file `refs/remotes/origin/master`:

[source,console]
----
$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
----

I riferimenti remoti differiscono dai branch (riferimenti in `refs/heads`) principalmente per il fatto che sono considerati a sola lettura.
Se ne può eseguire un `git checkout`, ma Git non vi punterà l'HEAD, quindi non lo si potrà mai aggiornare con un comando `commit`.
Git li gestisce come segnalibri (bookmark) all'ultimo stato conosciuto in cui si trovano i branch su quei server.
