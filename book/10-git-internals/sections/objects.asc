[[_objects]]
=== Gli oggetti Git

Git è un filesystem a contenuto indirizzabile.
Magnifico.
Ma cosa vuol dire?
Significa che il nucleo di Git è un semplice archivio dati chiave-valore.
Vi si può inserire qualsiasi tipo di contenuto e verrà restituita una chiave utilizzabile per recuperare, in seguito, quel contenuto.
Come dimostrazione si può usare il comando *plumbing* `hash-object` che prende dei dati, li salva nella directory `.git` e ne restituisce la chiave associata.
Per prima cosa si crea un nuovo repository Git e si verifica che la directory `objects` sia vuota:

[source,console]
----
$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
----

Git ha creato la directory `objects` e, al suo interno, le subdirectory `pack` e `info`, ma non ci sono file.
Ora si inserisce del testo nel database di Git:

[source,console]
----
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
----

L’opzione `-w` dice a `hash-object` di salvare l'oggetto; omettendola, il comando mostrerebbe soltanto la chiave associata all'oggetto.
`--stdin` dice al comando di leggere il contenuto dallo standard input, altrimenti `hash-object` si aspetta il percorso di un file.
L'output del comando è un checksum di 40 caratteri.
Questo è un hash SHA-1, un checksum del contenuto da salvare più un'intestazione, ma questo lo vedremo fra poco.
Analizziamo come Git ha salvato i dati:

[source,console]
----
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

C'è un file nella directory `objects`.
Questo è il modo in cui Git salva inizialmente il contenuto: un singolo file per ogni porzione di contenuto, il cui nome è ricavato dallo stesso checksum SHA-1 del contenuto e del suo header.
Il nome della subdirectory corrisponde ai primi 2 caratteri dello SHA, mentre il nome del file è uguale ai restanti 38 caratteri.

Il contenuto memorizzato si può estrarre col comando `cat-file`.
Questo comando è una specie di coltellino svizzero per ispezionare gli oggetti Git.
Con l'opzione `-p` si dice al comando `cat-file` d'interpretare il tipo di contenuto e mostrarlo in modo adeguato:


[source,console]
----
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
----

A questo punto si può aggiungere dell'altro in Git, per poi estrarlo.
Lo si può fare anche col contenuto dei file.
Si può, per esempio, implementare un semplice controllo di versione di un file.
Innanzi tutto si crea un nuovo file e se ne salva il contenuto nel database:

[source,console]
----
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
----

Quindi, si cambia il contenuto del file e lo si salva nuovamente:

[source,console]
----
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
----

Il database ora contiene sia le due nuove versioni del file che il contenuto già salvato all'inizio:

[source,console]
----
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Ora si può riportare il file alla prima versione

[source,console]
----
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
----

o alla seconda:

[source,console]
----
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
----

Ricordare la chiave SHA-1 di ogni versione di file non è per niente pratico e, come visto, viene salvato solo il contenuto dei file non i nomi.
Questo tipo di oggetto a chiamato blob.
Ci si può far dire, da Git, la tipologia di ciascun oggetto memorizzato, fornendone la chiave SHA-1, con `cat-file -t`:

[source,console]
----
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
----

[[_tree_objects]]
==== L’albero degli oggetti

Il tipo successivo è l'albero, che risolve il problema del salvataggio del nome del file e che consente anche di salvare un gruppo di file.
Git salva il contenuto in modo simile ad un filesystem UNIX, ma un po’ più semplificato.
Tutti i contenuti vengono salvati come oggetti albero o blob, dove gli alberi corrispondono alle directory UNIX e i blob corrispondono più o meno agli inode o al contenuto dei file.
Un singolo albero contiene una o più voci, ognuna delle quali contiene un puntatore SHA-1 a un blob o a un sottoalbero col suo modo, tipo e nome di file associato.
Ad esempio, l'albero più recente in un progetto potrebbe assomigliare a questo:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
----

La sintassi `master^{tree}` indica l'oggetto albero puntato dall'ultima commit del branch ‘master’.
Nota che la directory `lib` non è un blob ma un puntatore a un altro albero::

[source,console]
----
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
----

Concettualmente, i dati che vengono salvati da Git appaiono in questo modo:

.Versione semplificata del modello dei dati di Git.
image::images/data-model-1.png[Simple version of the Git data model.]

Un albero si crea facilmente.
Git di norma crea un albero prendendo lo stato dell'area di staging o l’indice e comincia a scrivere una una serie di oggetti albero.
Quindi, per creare un albero si deve prima impostare un indice mettendo in staging dei file.
Per creare un indice con un solo elemento - la prima versione del file test.txt - si usa il comando *plumbing* `update-index`.
Con questo comando si aggiunge artificialmente la versione precedente del file test.txt a una nuova area di staging.
Si devono usare le opzioni `--add` perché il file ancora non esiste nell'area di staging (e in effetti ancora non c'è un'area di staging) e `--cacheinfo`, perché il file che stai aggiungendo non sta nella directory ma nel database..
Infine, si specifica il modo, l’hash SHA-1 e il nome del file:

[source,console]
----
$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
----

In questo caso, si sta specificando il modo`100644`, indicando che si tratta di un normale file.
Altre opzioni sono `100755`, che indica un file eseguibile; e `120000`, per un link simbolico.
Il modo viene preso dai normali modi UNIX, ma è molto meno flessibile: questi tre sono gli unici validi per i file (blob) in Git (anche se ci sono altri modi utilizzati per le directory e i sotto-moduli).

Ora si può usare il comando `write-tree` per creare l'area di staging partendo da un oggetto albero.
L'opzione `-w` non è necessaria, perché l'esecuzione di `write-tree` crea automaticamente un oggetto albero a partire dallo stato dell'indice se l’albero ancora non esiste:

[source,console]
----
$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
----

Si può anche verificare che si tratta di un oggetto albero:

[source,console]
----
$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
----

Ora si creerà un nuovo albero con la seconda versione di test.txt e un nuovo file:

[source,console]
----
$ echo 'new file' > new.txt
$ git update-index test.txt
$ git update-index --add new.txt
----

L'area di staging ora contiene la nuova versione di test.txt così come il nuovo file new.txt.
Si scrive l'albero (registrando lo stato dell'area di staging e indice di un oggetto albero) e si vede a cosa assomiglia:

[source,console]
----
$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Si noti che questo albero ha entrambe le voci dei file e che, inoltre, l’hash SHA di test.txt è lo stesso SHA della precedente "versione 2" (`1f7a7a`).
Solo per divertimento, si aggiunga il primo albero come subdirectory dell'attuale.
Si possono vedere gli alberi nella tua area di staging eseguendo `read-tree`.
In questo caso, si può leggere un albero esistente nell'area di staging come sotto-albero tramite l'opzione `--prefix` di `read-tree`:

[source,console]
----
$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Se è stata creata una directory di lavoro dal nuovo albero appena scritto, si dovrebbero ottenerei due file nel primo livello della directory e una sotto-directory chiamata `bak` contenente la prima versione del file test.txt.
Si può pensare che i dati di Git per tali strutture assomiglino alla figura:

.La struttura dei contenuti degli attuali dati di Git.
image::images/data-model-2.png[The content structure of your current Git data.]

[[_git_commit_objects]]
==== Oggetti commit

A questo punto si avranno tre alberi che specificano i diversi snapshot del progetto delle quali si vuol tener traccia, ma resta il problema iniziale: si devono ricordare tutti e tre gli hash SHA-1 per poter recuperare le snapshot.
Inoltre non c'è nessuna informazione su chi ha salvato le snapshot, né quando le ha salvate né tanto meno perché.
Queste sono le informazioni contenute negli oggetti commit.

Per creare un oggetto commit si lancia `commit-tree` specificando un singolo albero SHA-1 e, se esiste, qual è la commit immediatamente precedente.
Si comincia col primo albero che scritto:

[source,console]
----
$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
----

Si può vedere il nuovo oggetto commit con `cat-file`:

[source,console]
----
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

first commit
----

Il formato di un oggetto commit è semplice: specifica l'albero di primo livello per lo snapshot del progetto in quel dato punto, le informazioni sull'autore delle modifiche o della commit (si usano le impostazioni `user.name` e `user.email` della configurazione ed un timestamp), una riga vuota ed infine il messaggio della commit.

Scriviamo, poi, gli altri due oggetti commit, ognuno dei quali fa riferimento alla commit immediatamente precedente:

[source,console]
----
$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
----

Ognuno dei tre oggetti commit punta ad uno dei tre alberi degli snapshot creati.
Ora c'è una vera e propria cronologia Git, consultabile col comando `git log`, eseguendolo con lo  SHA-1 dell'ultima commit si vedrà:

[source,console]
----
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
----

Fantastico.
Abbiamo appena eseguito tutte le operazioni di basso livello per costruire una cronologia Git senza utilizzare alcun comando del front end.
Questo è essenzialmente quello che Git fa quando si eseguono i comandi `git add` e `git commit`: salva i blob per i file modificati, aggiorna l'indice, scrive gli alberi e scrive gli oggetti commit che fanno riferimento agli alberi di primo livello e le commit immediatamente precedenti a questi.
Questi tre oggetti Git principali (il blob, l'albero, e la commit) vengono inizialmente salvati come file separati nella directory `.git/objects`.
Qui ci sono tutti gli oggetti nella directory di esempio, commentati con quello che contengono:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Se si seguono tutti i puntatori interni si otterrà il grafico di un oggetto simile a questo:

.Tutti gli oggetti nella directory di Git.
image::images/data-model-3.png[All the objects in your Git directory.]

==== Il salvataggio degli oggetti

Abbiamo detto che viene memorizzato un header, assieme al contenuto.
Prendiamoci un minuto per capire come Git salva i propri oggetti.
Vedremo come salvare un oggetto blob - in questo caso la stringa ``what is up, doc?'' - interattivamente con il linguaggio di scripting Ruby.

Si può lanciare Ruby in modalità interattiva col comando `irb`:

[source,console]
----
$ irb
>> content = "what is up, doc?"
=> "what is up, doc?"
----

Git costruisce una intestazione (header) che comincia con il tipo dell'oggetto, in questo caso un blob.
Aggiunge, uno spazio seguito dalla dimensione del contenuto ed infine da un byte *null*:

[source,console]
----
>> header = "blob #{content.length}\0"
=> "blob 16\u0000"
----

Git concatena l'header al contenuto originale e poi calcola il checksum SHA-1 del nuovo contenuto ottenuto.
Si può calcolare lo SHA-1 di una stringa in Ruby includendo la libreria digest SHA1 col comando `require` e invocando `Digest::SHA1.hexdigest()` con la stringa:

[source,console]
----
>> store = header + content
=> "blob 16\u0000what is up, doc?"
>> require 'digest/sha1'
=> true
>> sha1 = Digest::SHA1.hexdigest(store)
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
----

Git comprime il nuovo contenuto con zlib, cosa che in Ruby si può fare con la libreria zlib.
Prima di tutto c'è bisogno di includere la libreria, poi si invoca `Zlib::Deflate.deflate()` sul contenuto:

[source,console]
----
>> require 'zlib'
=> true
>> zlib_content = Zlib::Deflate.deflate(store)
=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
----

Infine, si scriverà il contenuto compresso con zlib, in un oggetto sul disco.
Si determinerà il percorso dell'oggetto da scrivere (i primi due caratteri dello SHA-1 sono il nome della subdirectory e gli ultimi 38 caratteri costituiranno il nome del file contenuto in quella directory).
In Ruby si può usare la funzione `FileUtils.mkdir_p()` per creare la subdirectory, se non esiste.
Poi si apre il file con `File.open()` e se ne scrive il contenuto, ottenuto dalla precedente compressione con zlib, chiamando `write()` col file handler ricevuto:

[source,console]
----
>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
>> require 'fileutils'
=> true
>> FileUtils.mkdir_p(File.dirname(path))
=> ".git/objects/bd"
>> File.open(path, 'w') { |f| f.write zlib_content }
=> 32
----

Questo è tutto - si è creato un oggetto Git valido di tipo blob.
Tutti gli oggetti Git vengono salvati nello stesso modo, solo con tipi differenti. Invece della stringa blob, l’intestazione comincerà con commit o tree.
Inoltre, sebbene il contenuto del blob possa essere praticamente qualsiasi cosa, i contenuti commit e tree sono formattati in un modo specifico.
