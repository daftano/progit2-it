=== Protocolli di trasferimento

Git può trasferire i dati tra due repository in due modi: col protocollo ``stupido'' o col protocollo ``intelligente''.
Questa sezione illustrerà rapidamente come funzionano questi due protocolli principali.

==== Il protocollo stupido

Per impostare un repository affinché risulti a sola lettura su HTTP, probabilmente si userà il protocollo stupido.
Questo protocollo è detto ``stupido'' perché durante il processo di trasporto non richiede alcun codice specifico di Git dal lato server; i prelievi [fetch] consistono in una serie di richieste HTTP `GET`, in cui il client può assumere la struttura del repository Git sul server.

[NOTE]
====
Attualmente il protocollo stupido è usato raramente.
È difficile da rendere sicuro o privato, quindi la maggior parte degli host Git (sia di tipo 'cloud' che 'on-premise' [installato localmente, Ndt.]) evitano di usarlo.
Generalmente, si consiglia di usare il protocollo smart (intelligente), descritto più avanti.
====

Seguiamo il processo `http-fetch` per la libreria simplegit:

[source,console]
----
$ git clone http://server/simplegit-progit.git
----

La prima cosa che fa questo comando è prelevare il file `info/refs`.
Questo file viene scritto dal comando `update-server-info`, che è il motivo per cui c'è bisogno di abilitare l’hook `post-receive` affinché il trasferimento su HTTP funzioni bene:

[source]
----
=> GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master
----

Ora si ha una lista dei riferimenti remoti e SHA.
Poi, si cerca a cosa faccia riferimento l’HEAD per sapere di cosa effettuare il 'check out' una volta finito:

[source]
----
=> GET HEAD
ref: refs/heads/master
----

Una volta completato il processo, si dovrà fare il check out del branch `master`.
A questo punto si è pronti per avviare il processo.
Dato che il punto di partenza è l'oggetto commit `ca82a6`, che si trova nel file `info/refs`, lo si comincia a prelevare:

[source]
----
=> GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)
----

Si otterrà un oggetto, che sul server è in formato sciolto, attraverso una richiesta GET statica su HTTP.
Lo si può decomprimere con zlib, rimuoverne l’intestazione e vedere il contenuto della commit:

[source,console]
----
$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

changed the version number
----

Ora ci sono altri due oggetti da recuperare: `cfda3b`, che è l'albero a cui fa riferimento la commit appena scaricata, e `085bb3`, che è la commit padre [una commit padre/madre??? Ndt.]:

[source]
----
=> GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)
----

Questo restituisce il successivo oggetto commit.
Si prende l’oggetto albero.

[source]
----
=> GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)
----

Oops — pare che l'oggetto sul server non sia in formato sciolto, e per questo si ottiene l'errore 404.
Ci sono due ragioni per cui questo possa accadere: o l'oggetto sta in un altro repository o è in questo ma racchiuso in un packfile.
Git cerca prima nella lista dei repository alternativi:

[source]
----
=> GET objects/info/http-alternates
(empty file)
----

Se questa restituisce una lista di URL alternativi, Git va a cerca nei repository elencati i file sciolti e i packfile: questo è un buon meccanismo per progetti che sono uno la biforcazione dell'altro per condividere gli oggetti sul disco.
Poiché però nel nostro caso  non c'è nessun repository alternativo, l'oggetto che cerchiamo dev'essere in un pacchetto.
Per sapere quali pacchetti sono disponibili sul server, si deve prelevare il file `objects/info/packs`, che ne contiene la lista completa (questo file viene generato anche da `update-server-info`):

[source]
----
=> GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
----

Sul server c'è un solo pacchetto, quindi il nostro oggetto è ovviamente lì, ma per esserne sicuri controlleremo il file indice.
Questo serve nel caso in cui ci siano più packfile sul server, così puoi da vedere quale pacchetto contiene l'oggetto cercato:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)
----

Ottenuto l'indice del packfile, si vedere se contiene l'oggetto, dato che l'indice contiene tutti gli SHA degli oggetti nel packfile ed i rispettivi offset.
L'oggetto è lì e quindi proseguiamo prendendo l'intero pacchetto:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)
----

Ci sono tre oggetti albero, quindi si continua a scorrere le commit.
Sono tutte nello stesso pacchetto appena scaricato, così non si devono fare ulteriori richieste al server.
Git crea una copia di lavoro con un check out del branch `master` riferito dal puntatore HEAD scaricato all'inizio.

==== Il protocollo intelligente

Il protocollo stupido è semplice ma alquanto inefficiente e non gestisce la scrittura dei dati dal client al server.
Il protocollo smart (intelligente) è un metodo più comune per trasferire dati, ma richiede un processo sul server remoto che conosca Git – sia in grado di leggere dati locali, capire cosa già possiede il client, cosa gli manca e generare un packfile personalizzato.
Ci sono due insiemi di processi per trasferire i dati: una coppia per inviarli e un'altra per scaricarli.

===== Invio dei dati

(((git commands, send-pack)))(((git commands, receive-pack)))
Per inviare dati ad un processo remoto, Git usa i processi `send-pack` e `receive-pack`.
Il processo `send-pack` gira sul client e si connette a un processo `receive-pack` sul lato remoto.

====== SSH

Per esempio, mettiamo che si esegua il comando `git push origin master` nel proprio progetto, e che `origin` è un URL che usa il protocollo SSH.
Git esegue il processo `send-pack` che avvia una connessione al server con SSH.
Tenta di eseguire un comando sul server remoto attraverso una chiamata SSH simile a questo:

[source,console]
----
$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
0000
----

Il comando `git-receive-pack` risponde immediatamente con una riga per ciascun riferimento posseduto (in questo caso solo il branch `master` e il relativo SHA).
La prima riga elenca anche le operazioni possibili sul server (nel nostro caso `report-status` e `delete-refs`, ed altro compreso l'identificativo del client).

Ogni riga inizia con un valore esadecimale di 4 caratteri che specifica la lunghezza del resto della riga.
La nostra prima riga inizia con 005b, ovvero 91 in esadecimale, quindi su questa riga ci sono altri 91 byte.
La riga successiva inizia con 003e, che è 62, e quindi restano da leggere altri 62 byte.
La riga successiva è 0000, segnalando la fine della lista dei riferimenti sul server.

Ora che conosce lo stato del server, il processo `send-pack` determina quali commit ha che non stanno sul server.
Per ogni riferimento che verrà aggiornato con questa push, il processo `send-pack` invia le informazioni al processo `receive-pack`.
Per esempio, se si aggiorna il branch `master` e si aggiunge un branch `experiment`, la risposta di `send-pack` sarà più o meno questa:


[source]
----
0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000
----

Git invia una riga per ogni riferimento da aggiornare con la lunghezza della riga, lo SHA precedente, il nuovo SHA e il riferimento che si sta aggiornando.
La prima riga indica anche le operazioni possibili del client.
Lo SHA-1 con tutti '0' significa che prima non c'era niente, perché stiamo aggiungendo il riferimento al branch experiment.
Se invece si cancella un riferimento, succede l'opposto: gli ‘0’ saranno sul lato destro.

Il client, poi, invia al server un packfile con tutti gli oggetti il server ancora non ha.
Il server conclude il trasferimento indicando che è andato a buon fine (o è fallito):

[source]
----
000Aunpack ok
----

====== HTTP(S)

Questo processo è praticamente lo stesso di quello su HTTP, anche se l'handshaking è un po' diverso.
La connessione viene avviata con questa richiesta:

[source]
----
=> GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
000000ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master \
	report-status delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000
----

Qui termina il primo scambio client-server.
Il client effettua poi un'altra richiesta, questa volta un `POST`, con i dati forniti da `git-upload-pack`.

[source]
----
=> POST http://server/simplegit-progit.git/git-receive/pack
----

La richiesta `POST` include l'output di `send-pack` e il packfile come messaggio (payload).
Il server, quindi,  indica il successo o il fallimento con la sua risposta HTTP.

===== Download dei dati

(((git commands, fetch-pack)))(((git commands, upload-pack)))
Quando si scaricano dati, si coinvolgono i processi `fetch-pack` e `upload-pack`.
Il client avvia il processo `fetch-pack` che si connette a un processo `upload-pack`, sul server remoto, per definire i dati che dovranno essere scaricati.

====== SSH

Se invece si esegue il fetch su SSH, il `fetch-pack` si lancia in un modo simile a questo:

[source,console]
----
$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"
----

Dopo che `fetch-pack` si è connesso, `upload-pack` rispedisce qualcosa di simile:

[source]
----
00dfca82a6dff817ec66f44342007202690a93763949 HEADmulti_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
----

Questa risposta è molto simile a quella di `receive-pack`, ma ha delle caratteristiche diverse.
In aggiunta, rispedisce quello a cui punta HEAD (`symref=HEAD:refs/heads/master`) in modo che il client sappia di cosa effettuare il checkout se è un clone.

A questo punto il processo `fetch-pack` cerca gli oggetti che già possiede e risponde indicando gli oggetti che gli mancano, inviando un "want" (voglio) e gli SHA desiderati.
Invia anche tutti gli oggetti che ha già, con un "have" (ho) e poi lo SHA.
Alla termine di questa lista scrive "done" (fatto), per invitare il processo `upload-pack` a inviare il pacchetto con i dati di cui hai bisogno:

[source]
----
0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0000
0009done
----

====== HTTP(S)

L'handshake per un'operazione di fetch richiede due richieste HTTP.
La prima è una `GET` allo stesso endpoint usato nel protocollo stupido:

[source]
----
=> GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
000000e7ca82a6dff817ec66f44342007202690a93763949 HEADmulti_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
----

Somiglia molto all'invocazione di `git-upload-pack` su una connessione SSH, ma il secondo scambio viene effettuato con una richiesta separata:

[source]
----
=> POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000
----

Ancora una volta, il formato è lo stesso del precedente.
La risposta a questa richiesta indica il successo o il fallimento, ed include il packfile.

==== Riepilogo dei protocolli

Questa sezione fornisce una panoramica molto elementare dei protocolli di trasferimento.
Il protocollo comprende molte altre funzionalità, come la capacità di `multi_ack` e `side-band`, ma ciò va oltre lo scopo di questo libro.
Abbiamo cercato di dare visione di massima del ping-pong dei dati tra client e server; per saperne di più c'è da sbirciare nel codice sorgente di Git.
