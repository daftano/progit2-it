1,2c1
< [[ch05-distributed-git]]
< == Distributed Git
---
> # Distributed Git #
4,5c3
< (((distributed git)))
< Now that you have a remote Git repository set up as a focal point for all the developers to share their code, and you're familiar with basic Git commands in a local workflow, you'll look at how to utilize some of the distributed workflows that Git affords you.
---
> Now that you have a remote Git repository set up as a point for all the developers to share their code, and you’re familiar with basic Git commands in a local workflow, you’ll look at how to utilize some of the distributed workflows that Git affords you.
7,8c5,6
< In this chapter, you'll see how to work with Git in a distributed environment as a contributor and an integrator.
< That is, you'll learn how to contribute code successfully to a project and make it as easy on you and the project maintainer as possible, and also how to maintain a project successfully with a number of developers contributing.
---
> In this chapter, you’ll see how to work with Git in a distributed environment as a contributor and an integrator.
> That is, you’ll learn how to contribute code successfully to a project and make it as easy on you and the project maintainer as possible, and also how to maintain a project successfully with a number of developers contributing.
9a8
> ## Distributed Workflows ##
11c10,14
< === Distributed Workflows
---
> Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.
> In centralized systems, every developer is a node working more or less equally on a central hub.
> In Git, however, every developer is potentially both a node and a hub — that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.
> This opens a vast range of workflow possibilities for your project and/or your team, so I’ll cover a few common paradigms that take advantage of this flexibility.
> I’ll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.
13,18c16
< (((workflows)))
< In contrast with Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.
< In centralized systems, every developer is a node working more or less equally with a central hub.
< In Git, however, every developer is potentially both a node and a hub; that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.
< This presents a vast range of workflow possibilities for your project and/or your team, so we'll cover a few common paradigms that take advantage of this flexibility.
< We'll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.
---
> ### Centralized Workflow ###
20c18,20
< ==== Centralized Workflow
---
> In centralized systems, there is generally a single collaboration model—the centralized workflow.
> One central hub, or repository, can accept code, and everyone synchronizes their work to it.
> A number of developers are nodes — consumers of that hub — and synchronize to that one place (see Figure 5-1).
22,28c22,23
< (((workflows, centralized)))
< In centralized systems, there is generally a single collaboration model -- the centralized workflow.
< One central hub, or _repository_, can accept code, and everyone synchronizes their work with it.
< A number of developers are nodes -- consumers of that hub -- and synchronize with that centralized location.
< 
< .Centralized workflow.
< image::images/centralized_workflow.png[Centralized workflow.]
---
> Insert 18333fig0501.png
> Figure 5-1. Centralized workflow.
31,32c26,33
< The second developer must merge in the first one's work before pushing changes up, so as not to overwrite the first developer's changes.
< This concept is as true in Git as it is in Subversion(((Subversion))) (or any CVCS), and this model works perfectly well in Git.
---
> The second developer must merge in the first one’s work before pushing changes up, so as not to overwrite the first developer’s changes.
> This concept is true in Git as it is in Subversion (or any CVCS), and this model works perfectly in Git.
> 
> If you have a small team or are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.
> Simply set up a single repository, and give everyone on your team push access; Git won’t let users overwrite each other.
> If one developer clones, makes changes, and then tries to push their changes while another developer has pushed in the meantime, the server will reject that developer’s changes.
> They will be told that they’re trying to push non-fast-forward changes and that they won’t be able to do so until they fetch and merge.
> This workflow is attractive to a lot of people because it’s a paradigm that many are familiar and comfortable with.
34,35c35
< If you are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.
< Simply set up a single repository, and give everyone on your team push access; Git won't let users overwrite each other.
---
> ### Integration-Manager Workflow ###
37,51c37,38
< Say John and Jessica both start working at the same time.
< John finishes his change and pushes it to the server.
< Then Jessica tries to push her changes, but the server rejects them.
< She is told that she's trying to push non-fast-forward changes and that she won't be able to do so until she fetches and merges.
< This workflow is attractive to a lot of people because it's a paradigm that many are familiar and comfortable with.
< 
< This is also not limited to small teams.
< With Git's branching model, it's possible for hundreds of developers to successfully work on a single project through dozens of branches simultaneously.
< 
< [[_integration_manager]]
< ==== Integration-Manager Workflow
< 
< (((workflows, integration manager)))
< Because Git allows you to have multiple remote repositories, it's possible to have a workflow where each developer has write access to their own public repository and read access to everyone else's.
< This scenario often includes a canonical repository that represents the ``official'' project.
---
> Because Git allows you to have multiple remote repositories, it’s possible to have a workflow where each developer has write access to their own public repository and read access to everyone else’s.
> This scenario often includes a canonical repository that represents the "official" project.
54,55c41,42
< The maintainer can then add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.
< The process works as follows (see <<wfdiag_b>>):
---
> They can add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.
> The process works as follows (see Figure 5-2):
60,61c47,48
< 4.  The contributor sends the maintainer an email asking them to pull changes.
< 5.  The maintainer adds the contributor's repository as a remote and merges locally.
---
> 4. The contributor sends the maintainer an e-mail asking them to pull changes.
> 5. The maintainer adds the contributor’s repo as a remote and merges locally.
64,66c51,52
< [[wfdiag_b]]
< .Integration-manager workflow.
< image::images/integration-manager.png[Integration-manager workflow.]
---
> Insert 18333fig0502.png
> Figure 5-2. Integration-manager workflow.
68,69c54
< (((forking)))
< This is a very common workflow with hub-based tools like GitHub or GitLab, where it's easy to fork a project and push your changes into your fork for everyone to see.
---
> This is a very common workflow with sites like GitHub, where it’s easy to fork a project and push your changes into your fork for everyone to see.
71c56
< Contributors don't have to wait for the project to incorporate their changes -- each party can work at their own pace.
---
> Contributors don’t have to wait for the project to incorporate their changes — each party can work at their own pace.
73c58
< ==== Dictator and Lieutenants Workflow
---
> ### Dictator and Lieutenants Workflow ###
75d59
< (((workflows, dictator and lieutenants)))
77,78c61,62
< It's generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
< Various integration managers are in charge of certain parts of the repository; they're called _lieutenants_.
---
> It’s generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
> Various integration managers are in charge of certain parts of the repository; they’re called lieutenants.
80,81c64,65
< The benevolent dictator pushes from his directory to a reference repository from which all the collaborators need to pull.
< The process works like this (see <<wfdiag_c>>):
---
> The benevolent dictator’s repository serves as the reference repository from which all the collaborators need to pull.
> The process works like this (see Figure 5-3):
83,91c67,70
< 1.  Regular developers work on their topic branch and rebase their work on top of `master`.
<     The `master` branch is that of the reference repository to which the dictator pushes.
< 2.  Lieutenants merge the developers' topic branches into their `master` branch.
< 3.  The dictator merges the lieutenants' `master` branches into the dictator's `master` branch.
< 4.  Finally, the dictator pushes that `master` branch to the reference repository so the other developers can rebase on it.
< 
< [[wfdiag_c]]
< .Benevolent dictator workflow.
< image::images/benevolent-dictator.png[Benevolent dictator workflow.]
---
> 1. Regular developers work on their topic branch and rebase their work on top of master. The master branch is that of the dictator.
> 2. Lieutenants merge the developers’ topic branches into their master branch.
> 3. The dictator merges the lieutenants’ master branches into the dictator’s master branch.
> 4. The dictator pushes their master to the reference repository so the other developers can rebase on it.
93,94c72,73
< This kind of workflow isn't common, but can be useful in very big projects, or in highly hierarchical environments.
< It allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.
---
> Insert 18333fig0503.png
> Figure 5-3. Benevolent dictator workflow.
96c75
< ==== Workflows Summary
---
> This kind of workflow isn’t common but can be useful in very big projects or in highly hierarchical environments, as it allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.
99,100c78
< Now that you can (hopefully) determine which workflow combination may work for you, we'll cover some more specific examples of how to accomplish the main roles that make up the different flows.
< In the next section, you'll learn about a few common patterns for contributing to a project.
---
> Now that you can (I hope) determine which workflow combination may work for you, I’ll cover some more specific examples of how to accomplish the main roles that make up the different flows.
101a80
> ## Contributing to a Project ##
103,104c82,83
< [[_contributing_project]]
< === Contributing to a Project
---
> You know what the different workflows are, and you should have a pretty good grasp of fundamental Git usage.
> In this section, you’ll learn about a few common patterns for contributing to a project.
106,109c85,87
< (((contributing)))
< The main difficulty with describing how to contribute to a project are the numerous variations on how to do that.
< Because Git is very flexible, people can and do work together in many ways, and it's problematic to describe how you should contribute -- every project is a bit different.
< Some of the variables involved are active contributor count, chosen workflow, your commit access, and possibly the external contribution method.
---
> The main difficulty with describing this process is that there are a huge number of variations on how it’s done.
> Because Git is very flexible, people can and do work together many ways, and it’s problematic to describe how you should contribute to a project — every project is a bit different.
> Some of the variables involved are active contributor size, chosen workflow, your commit access, and possibly the external contribution method.
111,113c89,91
< The first variable is active contributor count -- how many users are actively contributing code to this project, and how often?
< In many instances, you'll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.
< For larger companies or projects, the number of developers could be in the thousands, with hundreds or thousands of commits coming in each day.
---
> The first variable is active contributor size.
> How many users are actively contributing code to this project, and how often? In many instances, you’ll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.
> For really large companies or projects, the number of developers could be in the thousands, with dozens or even hundreds of patches coming in each day.
116c94
< How can you keep your code consistently up to date and your commits valid?
---
> How can you keep your code consistently up to date and your patches valid?
119,130c97,101
< Is it centralized, with each developer having equal write access to the main codeline?
< Does the project have a maintainer or integration manager who checks all the patches?
< Are all the patches peer-reviewed and approved?
< Are you involved in that process?
< Is a lieutenant system in place, and do you have to submit your work to them first?
< 
< The next variable is your commit access.
< The workflow required in order to contribute to a project is much different if you have write access to the project than if you don't.
< If you don't have write access, how does the project prefer to accept contributed work?
< Does it even have a policy?
< How much work are you contributing at a time?
< How often do you contribute?
---
> Is it centralized, with each developer having equal write access to the main codeline? Does the project have a maintainer or integration manager who checks all the patches? Are all the patches peer-reviewed and approved? Are you involved in that process? Is a lieutenant system in place, and do you have to submit your work to them first?
> 
> The next issue is your commit access.
> The workflow required in order to contribute to a project is much different if you have write access to the project than if you don’t.
> If you don’t have write access, how does the project prefer to accept contributed work? Does it even have a policy? How much work are you contributing at a time? How often do you contribute?
133c104
< We'll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.
---
> I’ll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.
135,136c106
< [[_commit_guidelines]]
< ==== Commit Guidelines
---
> ### Commit Guidelines ###
138c108
< Before we start looking at the specific use cases, here's a quick note about commit messages.
---
> Before you start looking at the specific use cases, here’s a quick note about commit messages.
140,144c110
< The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches -- you can read it in the Git source code in the `Documentation/SubmittingPatches` file.
< 
< (((git commands, diff, check)))
< First, your submissions should not contain any whitespace errors.
< Git provides an easy way to check for this -- before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.
---
> The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches — you can read it in the Git source code in the `Documentation/SubmittingPatches` file.
146,147c112,122
< .Output of `git diff --check`.
< image::images/git-diff-check.png[Output of `git diff --check`.]
---
> First, you don’t want to submit any whitespace errors.
> Git provides an easy way to check for this — before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.
> Here is an example, where I’ve replaced a red terminal color with `X`s:
> 
> 	$ git diff --check
> 	lib/simplegit.rb:5: trailing whitespace.
> 	+    @git_dir = File.expand_path(git_dir)XX
> 	lib/simplegit.rb:7: trailing whitespace.
> 	+ XXXXXXXXXXX
> 	lib/simplegit.rb:26: trailing whitespace.
> 	+    def command(git_cmd)XXXX
149c124
< If you run that command before committing, you can tell if you're about to commit whitespace issues that may annoy other developers.
---
> If you run that command before committing, you can tell if you’re about to commit whitespace issues that may annoy other developers.
152,154c127,129
< If you can, try to make your changes digestible -- don't code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
< Even if you don't commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.
< If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in <<ch07-git-tools#_interactive_staging>>).
---
> If you can, try to make your changes digestible — don’t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
> Even if you don’t commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.
> If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in Chapter 6).
156d130
< 
158c132
< <<ch07-git-tools#_rewriting_history>> describes a number of useful Git tricks for rewriting history and interactively staging files -- use these tools to help craft a clean and understandable history before sending the work to someone else.
---
> Chapter 6 describes a number of useful Git tricks for rewriting history and interactively staging files — use these tools to help craft a clean and understandable history.
162,180c136,153
< As a general rule, your messages should start with a single line that's no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.
< The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior -- this is a good guideline to follow.
< Write your commit message in the imperative: "Fix bug" and not "Fixed bug" or "Fixes bug."
< Here is a https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[template originally written by Tim Pope]:
< 
< [source,text]
< ----
< Capitalized, short (50 chars or less) summary
< 
< More detailed explanatory text, if necessary.  Wrap it to about 72
< characters or so.  In some contexts, the first line is treated as the
< subject of an email and the rest of the text as the body.  The blank
< line separating the summary from the body is critical (unless you omit
< the body entirely); tools like rebase can get confused if you run the
< two together.
< 
< Write your commit message in the imperative: "Fix bug" and not "Fixed bug"
< or "Fixes bug."  This convention matches up with commit messages generated
< by commands like git merge and git revert.
---
> As a general rule, your messages should start with a single line that’s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.
> The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior — this is a good guideline to follow.
> It’s also a good idea to use the imperative present tense in these messages.
> In other words, use commands.
> Instead of "I added tests for" or "Adding tests for," use "Add tests for."
> Here is a template originally written by Tim Pope at tpope.net:
> 
> 	Short (50 chars or less) summary of changes
> 
> 	More detailed explanatory text, if necessary.
>  Wrap it to about 72
> 	characters or so.
>  In some contexts, the first line is treated as the
> 	subject of an email and the rest of the text as the body.
>  The blank
> 	line separating the summary from the body is critical (unless you omit
> 	the body entirely); tools like rebase can get confused if you run the
> 	two together.
182c155
< Further paragraphs come after blank lines.
---
> 	Further paragraphs come after blank lines.
184c157
< - Bullet points are okay, too
---
> 	 - Bullet points are okay, too
186c159
< - Typically a hyphen or asterisk is used for the bullet, followed by a
---
> 	 - Typically a hyphen or asterisk is used for the bullet, preceded by a
189,190c162,166
< - Use a hanging indent
< ----
---
> If all your commit messages look like this, things will be a lot easier for you and the developers you work with.
> The Git project has well-formatted commit messages — I encourage you to run `git log --no-merges` there to see what a nicely formatted project-commit history looks like.
> 
> In the following examples, and throughout most of this book, for the sake of brevity I don’t format messages nicely like this; instead, I use the `-m` option to `git commit`.
> Do as I say, not as I do.
192,193c168
< If all your commit messages follow this model, things will be much easier for you and the developers with whom you collaborate.
< The Git project has well-formatted commit messages -- try running `git log --no-merges` there to see what a nicely-formatted project-commit history looks like.
---
> ### Private Small Team ###
195,208c170,171
< [NOTE]
< .Do as we say, not as we do.
< ====
< For the sake of brevity, many of the examples in this book don't have nicely-formatted commit messages like this; instead, we simply use the `-m` option to `git commit`.
< 
< In short, do as we say, not as we do.
< ====
< 
< [[_private_team]]
< ==== Private Small Team
< 
< (((contributing, private small team)))
< The simplest setup you're likely to encounter is a private project with one or two other developers.
< ``Private,'' in this context, means closed-source -- not accessible to the outside world.
---
> The simplest setup you’re likely to encounter is a private project with one or two other developers.
> By private, I mean closed source — not read-accessible to the outside world.
213c176
< Let's see what it might look like when two developers start to work together with a shared repository.
---
> Let’s see what it might look like when two developers start to work together with a shared repository.
215c178
< (The protocol messages have been replaced with `...` in these examples to shorten them somewhat.)
---
> (I’m replacing the protocol messages with `...` in these examples to shorten them somewhat.)
217,226c180,187
< [source,console]
< ----
< # John's Machine
< $ git clone john@githost:simplegit.git
< Cloning into 'simplegit'...
< ...
< $ cd simplegit/
< $ vim lib/simplegit.rb
< $ git commit -am 'remove invalid default value'
< [master 738ee87] remove invalid default value
---
> 	# John's Machine
> 	$ git clone john@githost:simplegit.git
> 	Initialized empty Git repository in /home/john/simplegit/.git/
> 	...
> 	$ cd simplegit/
> 	$ vim lib/simplegit.rb
> 	$ git commit -am 'removed invalid default value'
> 	[master 738ee87] removed invalid default value
228d188
< ----
230c190
< The second developer, Jessica, does the same thing -- clones the repository and commits a change:
---
> The second developer, Jessica, does the same thing — clones the repository and commits a change:
232,241c192,199
< [source,console]
< ----
< # Jessica's Machine
< $ git clone jessica@githost:simplegit.git
< Cloning into 'simplegit'...
< ...
< $ cd simplegit/
< $ vim TODO
< $ git commit -am 'add reset task'
< [master fbff5bc] add reset task
---
> 	# Jessica's Machine
> 	$ git clone jessica@githost:simplegit.git
> 	Initialized empty Git repository in /home/jessica/simplegit/.git/
> 	...
> 	$ cd simplegit/
> 	$ vim TODO
> 	$ git commit -am 'add reset task'
> 	[master fbff5bc] add reset task
243d200
< ----
245c202
< Now, Jessica pushes her work to the server, which works just fine:
---
> Now, Jessica pushes her work up to the server:
247,252c204,207
< [source,console]
< ----
< # Jessica's Machine
< $ git push origin master
< ...
< To jessica@githost:simplegit.git
---
> 	# Jessica's Machine
> 	$ git push origin master
> 	...
> 	To jessica@githost:simplegit.git
254d208
< ----
256,267c210,214
< The last line of the output above shows a useful return message from the push operation.
< The basic format is `<oldref>..<newref> fromref -> toref`, where `oldref` means the old reference, `newref` means the new reference, `fromref` is the name of the local reference being pushed, and `toref` is the name of the remote reference being updated.
< You'll see similar output like this below in the discussions, so having a basic idea of the meaning will help in understanding the various states of the repositories.
< More details are available in the documentation for https://git-scm.com/docs/git-push[git-push].
< 
< Continuing with this example, shortly afterwards, John makes some changes, commits them to his local repository, and tries to push them to the same server:
< 
< [source,console]
< ----
< # John's Machine
< $ git push origin master
< To john@githost:simplegit.git
---
> John tries to push his change up, too:
> 
> 	# John's Machine
> 	$ git push origin master
> 	To john@githost:simplegit.git
269,270c216
< error: failed to push some refs to 'john@githost:simplegit.git'
< ----
---
> 	error: failed to push some refs to 'john@githost:simplegit.git'
272,283c218,225
< In this case, John's push fails because of Jessica's earlier push of _her_ changes.
< This is especially important to understand if you're used to Subversion, because you'll notice that the two developers didn't edit the same file.
< Although Subversion automatically does such a merge on the server if different files are edited, with Git, you must _first_ merge the commits locally.
< In other words, John must first fetch Jessica's upstream changes and merge them into his local repository before he will be allowed to push.
< 
< As a first step, John fetches Jessica's work (this only _fetches_ Jessica's upstream work, it does not yet merge it into John's work):
< 
< [source,console]
< ----
< $ git fetch origin
< ...
< From john@githost:simplegit
---
> John isn’t allowed to push because Jessica has pushed in the meantime.
> This is especially important to understand if you’re used to Subversion, because you’ll notice that the two developers didn’t edit the same file.
> Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.
> John has to fetch Jessica’s changes and merge them in before he will be allowed to push:
> 
> 	$ git fetch origin
> 	...
> 	From john@githost:simplegit
285d226
< ----
287c228
< At this point, John's local repository looks something like this:
---
> At this point, John’s local repository looks something like Figure 5-4.
289,290c230,231
< .John's divergent history.
< image::images/small-team-1.png[John's divergent history.]
---
> Insert 18333fig0504.png
> Figure 5-4. John’s initial repository.
292c233
< Now John can merge Jessica's work that he fetched into his own local work:
---
> John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:
294,297c235,236
< [source,console]
< ----
< $ git merge origin/master
< Merge made by the 'recursive' strategy.
---
> 	$ git merge origin/master
> 	Merge made by recursive.
300d238
< ----
302c240
< As long as that local merge goes smoothly, John's updated history will now look like this:
---
> The merge goes smoothly — John’s commit history now looks like Figure 5-5.
304,305c242,243
< .John's repository after merging `origin/master`.
< image::images/small-team-2.png[John's repository after merging `origin/master`.]
---
> Insert 18333fig0505.png
> Figure 5-5. John’s repository after merging `origin/master`.
307c245
< At this point, John might want to test this new code to make sure none of Jessica's work affects any of his and, as long as everything seems fine, he can finally push the new merged work up to the server:
---
> Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:
309,313c247,249
< [source,console]
< ----
< $ git push origin master
< ...
< To john@githost:simplegit.git
---
> 	$ git push origin master
> 	...
> 	To john@githost:simplegit.git
315d250
< ----
317c252
< In the end, John's commit history will look like this:
---
> Finally, John’s commit history looks like Figure 5-6.
319,320c254,255
< .John's history after pushing to the `origin` server.
< image::images/small-team-3.png[John's history after pushing to the `origin` server.]
---
> Insert 18333fig0506.png
> Figure 5-6. John’s history after pushing to the origin server.
322,323c257,259
< In the meantime, Jessica has created a new topic branch called `issue54`, and made three commits to that branch.
< She hasn't fetched John's changes yet, so her commit history looks like this:
---
> In the meantime, Jessica has been working on a topic branch.
> She’s created a topic branch called `issue54` and done three commits on that branch.
> She hasn’t fetched John’s changes yet, so her commit history looks like Figure 5-7.
325,326c261,262
< .Jessica's topic branch.
< image::images/small-team-4.png[Jessica's topic branch.]
---
> Insert 18333fig0507.png
> Figure 5-7. Jessica’s initial commit history.
328c264
< Suddenly, Jessica learns that John has pushed some new work to the server and she wants to take a look at it, so she can fetch all new content from the server that she does not yet have with:
---
> Jessica wants to sync up with John, so she fetches:
330,335c266,269
< [source,console]
< ----
< # Jessica's Machine
< $ git fetch origin
< ...
< From jessica@githost:simplegit
---
> 	# Jessica's Machine
> 	$ git fetch origin
> 	...
> 	From jessica@githost:simplegit
337d270
< ----
340c273
< Jessica's history now looks like this:
---
> Jessica’s history now looks like Figure 5-8.
342,343c275,276
< .Jessica's history after fetching John's changes.
< image::images/small-team-5.png[Jessica's history after fetching John's changes.]
---
> Insert 18333fig0508.png
> Figure 5-8. Jessica’s history after fetching John’s changes.
345c278
< Jessica thinks her topic branch is ready, but she wants to know what part of John's fetched work she has to merge into her work so that she can push.
---
> Jessica thinks her topic branch is ready, but she wants to know what she has to merge her work into so that she can push.
348,383c281,301
< [source,console]
< ----
< $ git log --no-merges issue54..origin/master
< commit 738ee872852dfaa9d6634e0dea7a324040193016
< Author: John Smith <jsmith@example.com>
< Date:   Fri May 29 16:01:27 2009 -0700
< 
<    remove invalid default value
< ----
< 
< The `issue54..origin/master` syntax is a log filter that asks Git to display only those commits that are on the latter branch (in this case `origin/master`) that are not on the first branch (in this case `issue54`).
< We'll go over this syntax in detail in <<ch07-git-tools#_commit_ranges>>.
< 
< From the above output, we can see that there is a single commit that John has made that Jessica has not merged into her local work.
< If she merges `origin/master`, that is the single commit that will modify her local work.
< 
< Now, Jessica can merge her topic work into her master branch, merge John's work (`origin/master`) into her `master` branch, and then push back to the server again.
< 
< First (having committed all of the work on her `issue54` topic branch), Jessica switches back to her master branch in preparation for integrating all this work:
< 
< [source,console]
< ----
< $ git checkout master
< Switched to branch 'master'
< Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
< ----
< 
< Jessica can merge either `origin/master` or `issue54` first -- they're both upstream, so the order doesn't matter.
< The end snapshot should be identical no matter which order she chooses; only the history will be different.
< She chooses to merge the `issue54` branch  first:
< 
< [source,console]
< ----
< $ git merge issue54
< Updating fbff5bc..4af4298
< Fast forward
---
> 	$ git log --no-merges origin/master ^issue54
> 	commit 738ee872852dfaa9d6634e0dea7a324040193016
> 	Author: John Smith <jsmith@example.com>
> 	Date:   Fri May 29 16:01:27 2009 -0700
> 
> 	    removed invalid default value
> 
> Now, Jessica can merge her topic work into her `master` branch, merge John’s work (`origin/master`) into her `master` branch, and then push back to the server again.
> First, she switches back to her `master` branch to integrate all this work:
> 
> 	$ git checkout master
> 	Switched to branch "master"
> 	Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
> 
> She can merge either `origin/master` or `issue54` first — they’re both upstream, so the order doesn’t matter.
> The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.
> She chooses to merge in `issue54` first:
> 
> 	$ git merge issue54
> 	Updating fbff5bc..4af4298
> 	Fast forward
387d304
< ----
389,390c306,307
< No problems occur; as you can see it was a simple fast-forward merge.
< Jessica now completes the local merging process by merging John's earlier fetched work that is sitting in the `origin/master` branch:
---
> No problems occur; as you can see, it was a simple fast-forward.
> Now Jessica merges in John’s work (`origin/master`):
392,396c309,311
< [source,console]
< ----
< $ git merge origin/master
< Auto-merging lib/simplegit.rb
< Merge made by the 'recursive' strategy.
---
> 	$ git merge origin/master
> 	Auto-merging lib/simplegit.rb
> 	Merge made by recursive.
399d313
< ----
401c315
< Everything merges cleanly, and Jessica's history now looks like this:
---
> Everything merges cleanly, and Jessica’s history looks like Figure 5-9.
403,404c317,318
< .Jessica's history after merging John's changes.
< image::images/small-team-6.png[Jessica's history after merging John's changes.]
---
> Insert 18333fig0509.png
> Figure 5-9. Jessica’s history after merging John’s changes.
406c320
< Now `origin/master` is reachable from Jessica's `master` branch, so she should be able to successfully push (assuming John hasn't pushed even more changes in the meantime):
---
> Now `origin/master` is reachable from Jessica’s `master` branch, so she should be able to successfully push (assuming John hasn’t pushed again in the meantime):
408,412c322,324
< [source,console]
< ----
< $ git push origin master
< ...
< To jessica@githost:simplegit.git
---
> 	$ git push origin master
> 	...
> 	To jessica@githost:simplegit.git
414d325
< ----
416c327
< Each developer has committed a few times and merged each other's work successfully.
---
> Each developer has committed a few times and merged each other’s work successfully; see Figure 5-10.
418,419c329,330
< .Jessica's history after pushing all changes back to the server.
< image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]
---
> Insert 18333fig0510.png
> Figure 5-10. Jessica’s history after pushing all changes back to the server.
422,424c333,335
< You work for a while (generally in a topic branch), and merge that work into your `master` branch when it's ready to be integrated.
< When you want to share that work, you fetch and merge your `master` from `origin/master` if it has changed, and finally push to the `master` branch on the server.
< The general sequence is something like this:
---
> You work for a while, generally in a topic branch, and merge into your `master` branch when it’s ready to be integrated.
> When you want to share that work, you merge it into your own `master` branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.
> The general sequence is something like that shown in Figure 5-11.
426,427c337,338
< .General sequence of events for a simple multiple-developer Git workflow.
< image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]
---
> Insert 18333fig0511.png
> Figure 5-11. General sequence of events for a simple multiple-developer Git workflow.
429c340
< ==== Private Managed Team
---
> ### Private Managed Team ###
431,433c342,343
< (((contributing, private managed team)))
< In this next scenario, you'll look at contributor roles in a larger private group.
< You'll learn how to work in an environment where small groups collaborate on features, after which those team-based contributions are integrated by another party.
---
> In this next scenario, you’ll look at contributor roles in a larger private group.
> You’ll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.
435c345
< Let's say that John and Jessica are working together on one feature (call this ``featureA''), while Jessica and a third developer, Josie, are working on a second (say, ``featureB'').
---
> Let’s say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
439c349
< Let's follow Jessica's workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
---
> Let’s follow Jessica’s workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
443,450c353,358
< [source,console]
< ----
< # Jessica's Machine
< $ git checkout -b featureA
< Switched to a new branch 'featureA'
< $ vim lib/simplegit.rb
< $ git commit -am 'add limit to log function'
< [featureA 3300904] add limit to log function
---
> 	# Jessica's Machine
> 	$ git checkout -b featureA
> 	Switched to a new branch "featureA"
> 	$ vim lib/simplegit.rb
> 	$ git commit -am 'add limit to log function'
> 	[featureA 3300904] add limit to log function
452d359
< ----
455c362
< Jessica doesn't have push access to the `master` branch -- only the integrators do -- so she has to push to another branch in order to collaborate with John:
---
> Jessica doesn’t have push access to the `master` branch — only the integrators do — so she has to push to another branch in order to collaborate with John:
457,461c364,366
< [source,console]
< ----
< $ git push -u origin featureA
< ...
< To jessica@githost:simplegit.git
---
> 	$ git push origin featureA
> 	...
> 	To jessica@githost:simplegit.git
463d367
< ----
465c369
< Jessica emails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
---
> Jessica e-mails John to tell him that she’s pushed some work into a branch named `featureA` and he can look at it now.
467c371
< To begin, she starts a new feature branch, basing it off the server's `master` branch:
---
> To begin, she starts a new feature branch, basing it off the server’s `master` branch:
469,475c373,376
< [source,console]
< ----
< # Jessica's Machine
< $ git fetch origin
< $ git checkout -b featureB origin/master
< Switched to a new branch 'featureB'
< ----
---
> 	# Jessica's Machine
> 	$ git fetch origin
> 	$ git checkout -b featureB origin/master
> 	Switched to a new branch "featureB"
479,483c380,382
< [source,console]
< ----
< $ vim lib/simplegit.rb
< $ git commit -am 'made the ls-tree function recursive'
< [featureB e5b0fdc] made the ls-tree function recursive
---
> 	$ vim lib/simplegit.rb
> 	$ git commit -am 'made the ls-tree function recursive'
> 	[featureB e5b0fdc] made the ls-tree function recursive
485,487c384,386
< $ vim lib/simplegit.rb
< $ git commit -am 'add ls-files'
< [featureB 8512791] add ls-files
---
> 	$ vim lib/simplegit.rb
> 	$ git commit -am 'add ls-files'
> 	[featureB 8512791] add ls-files
489d387
< ----
491c389
< Jessica's repository now looks like this:
---
> Jessica’s repository looks like Figure 5-12.
493,494c391,392
< .Jessica's initial commit history.
< image::images/managed-team-1.png[Jessica's initial commit history.]
---
> Insert 18333fig0512.png
> Figure 5-12. Jessica’s initial commit history.
496,504c394,400
< She's ready to push her work, but gets an email from Josie that a branch with some initial ``featureB'' work on it was already pushed to the server as the `featureBee` branch.
< Jessica needs to merge those changes with her own before she can push her work to the server.
< Jessica first fetches Josie's changes with `git fetch`:
< 
< [source,console]
< ----
< $ git fetch origin
< ...
< From jessica@githost:simplegit
---
> She’s ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
> Jessica first needs to merge those changes in with her own before she can push to the server.
> She can then fetch Josie’s changes down with `git fetch`:
> 
> 	$ git fetch origin
> 	...
> 	From jessica@githost:simplegit
506d401
< ----
508c403
< Assuming Jessica is still on her checked-out `featureB` branch, she can now merge Josie's work into that branch with `git merge`:
---
> Jessica can now merge this into the work she did with `git merge`:
510,514c405,407
< [source,console]
< ----
< $ git merge origin/featureBee
< Auto-merging lib/simplegit.rb
< Merge made by the 'recursive' strategy.
---
> 	$ git merge origin/featureBee
> 	Auto-merging lib/simplegit.rb
> 	Merge made by recursive.
517d409
< ----
519,520c411,412
< At this point, Jessica wants to push all of this merged ``featureB'' work back to the server, but she doesn't want to simply push her own `featureB` branch.
< Rather, since Josie has already started an upstream `featureBee` branch, Jessica wants to push to _that_ branch, which she does with:
---
> There is a bit of a problem — she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.
> She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:
522,526c414,416
< [source,console]
< ----
< $ git push -u origin featureB:featureBee
< ...
< To jessica@githost:simplegit.git
---
> 	$ git push origin featureB:featureBee
> 	...
> 	To jessica@githost:simplegit.git
528d417
< ----
531,532c420
< See <<ch10-git-internals#_refspec>> for a more detailed discussion of Git refspecs and different things you can do with them.
< Also notice the `-u` flag; this is short for `--set-upstream`, which configures the branches for easier pushing and pulling later.
---
> See Chapter 9 for a more detailed discussion of Git refspecs and different things you can do with them.
534,535c422,423
< Suddenly, Jessica gets email from John, who tells her he's pushed some changes to the `featureA` branch on which they are collaborating, and he asks Jessica to take a look at them.
< Again, Jessica runs a simple `git fetch` to fetch _all_ new content from the server, including (of course) John's latest work:
---
> Next, John e-mails Jessica to say he’s pushed some changes to the `featureA` branch and ask her to verify them.
> She runs a `git fetch` to pull down those changes:
537,541c425,427
< [source,console]
< ----
< $ git fetch origin
< ...
< From jessica@githost:simplegit
---
> 	$ git fetch origin
> 	...
> 	From jessica@githost:simplegit
543d428
< ----
545c430
< Jessica can display the log of John's new work by comparing the content of the newly-fetched `featureA` branch with her local copy of the same branch:
---
> Then, she can see what has been changed with `git log`:
547,552c432,435
< [source,console]
< ----
< $ git log featureA..origin/featureA
< commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
< Author: John Smith <jsmith@example.com>
< Date:   Fri May 29 19:57:33 2009 -0700
---
> 	$ git log origin/featureA ^featureA
> 	commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
> 	Author: John Smith <jsmith@example.com>
> 	Date:   Fri May 29 19:57:33 2009 -0700
555d437
< ----
557c439
< If Jessica likes what she sees, she can merge John's new work into her local `featureA` branch with:
---
> Finally, she merges John’s work into her own `featureA` branch:
559,565c441,445
< [source,console]
< ----
< $ git checkout featureA
< Switched to branch 'featureA'
< $ git merge origin/featureA
< Updating 3300904..aad881d
< Fast forward
---
> 	$ git checkout featureA
> 	Switched to branch "featureA"
> 	$ git merge origin/featureA
> 	Updating 3300904..aad881d
> 	Fast forward
567,568c447
< 1 files changed, 9 insertions(+), 1 deletions(-)
< ----
---
> 	1 files changed, 9 insertions(+), 1 deletions(-)
570c449
< Finally, Jessica might want to make a couple minor changes to all that merged content, so she is free to make those changes, commit them to her local `featureA` branch, and push the end result back to the server.
---
> Jessica wants to tweak something, so she commits again and then pushes this back up to the server:
572,575c451,452
< [source,console]
< ----
< $ git commit -am 'small tweak'
< [featureA 774b3ed] small tweak
---
> 	$ git commit -am 'small tweak'
> 	[featureA 774b3ed] small tweak
577,579c454,456
< $ git push
< ...
< To jessica@githost:simplegit.git
---
> 	$ git push origin featureA
> 	...
> 	To jessica@githost:simplegit.git
581d457
< ----
583c459
< Jessica's commit history now looks something like this:
---
> Jessica’s commit history now looks something like Figure 5-13.
585,586c461,462
< .Jessica's history after committing on a feature branch.
< image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]
---
> Insert 18333fig0513.png
> Figure 5-13. Jessica’s history after committing on a feature branch.
588,589c464,465
< At some point, Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
< After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:
---
> Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
> After they integrate these branches into the mainline, a fetch will bring down the new merge commits, making the commit history look like Figure 5-14.
591,592c467,468
< .Jessica's history after merging both her topic branches.
< image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]
---
> Insert 18333fig0514.png
> Figure 5-14. Jessica’s history after merging both her topic branches.
596c472
< The sequence for the workflow you saw here is something like this:
---
> The sequence for the workflow you saw here is something like Figure 5-15.
598,599c474,475
< .Basic sequence of this managed-team workflow.
< image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]
---
> Insert 18333fig0515.png
> Figure 5-15. Basic sequence of this managed-team workflow.
601,602c477
< [[_public_project]]
< ==== Forked Public Project
---
> ### Public Small Project ###
604d478
< (((contributing, public small project)))
606c480
< Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
---
> Because you don’t have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
608,609c482,483
< Many hosting sites support this (including GitHub, BitBucket, repo.or.cz, and others), and many project maintainers expect this style of contribution.
< The next section deals with projects that prefer to accept contributed patches via email.
---
> The repo.or.cz and GitHub hosting sites both support this, and many project maintainers expect this style of contribution.
> The next section deals with projects that prefer to accept contributed patches via e-mail.
611c485
< First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
---
> First, you’ll probably want to clone the main repository, create a topic branch for the patch or patch series you’re planning to contribute, and do your work there.
614,661c488,518
< [source,console]
< ----
< $ git clone <url>
< $ cd project
< $ git checkout -b featureA
<   ... work ...
< $ git commit
<   ... work ...
< $ git commit
< ----
< 
< [NOTE]
< ====
< You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review -- see <<ch07-git-tools#_rewriting_history>> for more information about interactive rebasing.
< ====
< 
< When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
< You then need to add this repository URL as a new remote of your local repository; in this example, let's call it `myfork`:
< 
< [source,console]
< ----
< $ git remote add myfork <url>
< ----
< 
< You then need to push your new work to this repository.
< It's easiest to push the topic branch you're working on to your forked repository, rather than merging that work into your master branch and pushing that.
< The reason is that if your work isn't accepted or is cherry-picked, you don't have to rewind your master branch (the Git `cherry-pick` operation is covered in more detail in <<ch05-distributed-git#_rebase_cherry_pick>>).
< If the maintainers `merge`, `rebase`, or `cherry-pick` your work, you'll eventually get it back via pulling from their repository anyhow.
< 
< In any event, you can push your work with:
< 
< [source,console]
< ----
< $ git push -u myfork featureA
< ----
< 
< (((git commands, request-pull)))
< Once your work has been pushed to your fork of the repository, you need to notify the maintainers of the original project that you have work you'd like them to merge.
< This is often called a _pull request_, and you typically generate such a request either via the website -- GitHub has its own ``Pull Request'' mechanism that we'll go over in <<ch06-github#ch06-github>> -- or you can run the `git request-pull` command and email the subsequent output to the project maintainer manually.
< 
< The `git request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and produces a summary of all the changes you're asking to be pulled.
< For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed, she can run this:
< 
< [source,console]
< ----
< $ git request-pull origin/master myfork
< The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
< Jessica Smith (1):
---
> 	$ git clone (url)
> 	$ cd project
> 	$ git checkout -b featureA
> 	$ (work)
> 	$ git commit
> 	$ (work)
> 	$ git commit
> 
> You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review — see Chapter 6 for more information about interactive rebasing.
> 
> When your branch work is finished and you’re ready to contribute it back to the maintainers, go to the original project page and click the "Fork" button, creating your own writable fork of the project.
> You then need to add in this new repository URL as a second remote, in this case named `myfork`:
> 
> 	$ git remote add myfork (url)
> 
> You need to push your work up to it.
> It’s easiest to push the remote branch you’re working on up to your repository, rather than merging into your master branch and pushing that up.
> The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch.
> If the maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it back via pulling from their repository anyhow:
> 
> 	$ git push myfork featureA
> 
> When your work has been pushed up to your fork, you need to notify the maintainer.
> This is often called a pull request, and you can either generate it via the website — GitHub has a "pull request" button that automatically messages the maintainer — or run the `git request-pull` command and e-mail the output to the project maintainer manually.
> 
> The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you’re asking to be pulled in.
> For instance, if Jessica wants to send John a pull request, and she’s done two commits on the topic branch she just pushed up, she can run this:
> 
> 	$ git request-pull origin/master myfork
> 	The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
> 	  John Smith (1):
664c521
< are available in the git repository at:
---
> 	are available in the git repository at:
668c525
< Jessica Smith (2):
---
> 	Jessica Smith (2):
674d530
< ----
676c532,536
< This output can be sent to the maintainer -- it tells them where the work was branched from, summarizes the commits, and identifies from where the new work is to be pulled.
---
> The output can be sent to the maintainer—it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.
> 
> On a project for which you’re not the maintainer, it’s generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they’re rejected.
>  Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
> For example, if you want to submit a second topic of work to the project, don’t continue working on the topic branch you just pushed up — start over from the main repository’s `master` branch:
678,691c538,543
< On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
< Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
< For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up -- start over from the main repository's `master` branch:
< 
< [source,console]
< ----
< $ git checkout -b featureB origin/master
<   ... work ...
< $ git commit
< $ git push myfork featureB
< $ git request-pull origin/master myfork
<   ... email generated request pull to maintainer ...
< $ git fetch origin
< ----
---
> 	$ git checkout -b featureB origin/master
> 	$ (work)
> 	$ git commit
> 	$ git push myfork featureB
> 	$ (email maintainer)
> 	$ git fetch origin
693c545
< Now, each of your topics is contained within a silo -- similar to a patch queue -- that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:
---
> Now, each of your topics is contained within a silo — similar to a patch queue — that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other as in Figure 5-16.
695,696c547,548
< .Initial commit history with `featureB` work.
< image::images/public-small-1.png[Initial commit history with `featureB` work.]
---
> Insert 18333fig0516.png
> Figure 5-16. Initial commit history with featureB work.
698c550
< Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
---
> Let’s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
701,712c553,555
< [source,console]
< ----
< $ git checkout featureA
< $ git rebase origin/master
< $ git push -f myfork featureA
< ----
< 
< This rewrites your history to now look like <<psp_b>>.
< 
< [[psp_b]]
< .Commit history after `featureA` work.
< image::images/public-small-2.png[Commit history after `featureA` work.]
---
> 	$ git checkout featureA
> 	$ git rebase origin/master
> 	$ git push -f myfork featureA
714c557,562
< Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
---
> This rewrites your history to now look like Figure 5-17.
> 
> Insert 18333fig0517.png
> Figure 5-17. Commit history after featureA work.
> 
> Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn’t a descendant of it.
717,745c565,573
< Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
< You'll also take this opportunity to move the work to be based off the project's current `master` branch.
< You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that as a new branch:
< 
< (((git commands, merge, squash)))
< [source,console]
< ----
< $ git checkout -b featureBv2 origin/master
< $ git merge --squash featureB
<   ... change implementation ...
< $ git commit
< $ git push myfork featureBv2
< ----
< 
< The `--squash` option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit.
< This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
< Also the `--no-commit` option can be useful to delay the merge commit in case of the default merge process.
< 
< At this point, you can notify the maintainer that you've made the requested changes, and that they can find those changes in your `featureBv2` branch.
< 
< .Commit history after `featureBv2` work.
< image::images/public-small-3.png[Commit history after `featureBv2` work.]
< 
< [[_project_over_email]]
< ==== Public Project over Email
< 
< (((contributing, public large project)))
< Many projects have established procedures for accepting patches -- you'll need to check the specific rules for each project, because they will differ.
< Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.
---
> Let’s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
> You’ll also take this opportunity to move the work to be based off the project’s current `master` branch.
> You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:
> 
> 	$ git checkout -b featureBv2 origin/master
> 	$ git merge --no-commit --squash featureB
> 	$ (change implementation)
> 	$ git commit
> 	$ git push myfork featureBv2
747c575,589
< The workflow is similar to the previous use case -- you create topic branches for each patch series you work on.
---
> The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you’re on.
> The `--no-commit` option tells Git not to automatically record a commit.
> This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
> 
> Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your `featureBv2` branch (see Figure 5-18).
> 
> Insert 18333fig0518.png
> Figure 5-18. Commit history after featureBv2 work.
> 
> ### Public Large Project ###
> 
> Many larger projects have established procedures for accepting patches — you’ll need to check the specific rules for each project, because they will differ.
> However, many larger public projects accept patches via a developer mailing list, so I’ll go over an example of that now.
> 
> The workflow is similar to the previous use case — you create topic branches for each patch series you work on.
749c591
< Instead of forking the project and pushing to your own writable version, you generate email versions of each commit series and email them to the developer mailing list:
---
> Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:
751,758c593,597
< [source,console]
< ----
< $ git checkout -b topicA
<   ... work ...
< $ git commit
<   ... work ...
< $ git commit
< ----
---
> 	$ git checkout -b topicA
> 	$ (work)
> 	$ git commit
> 	$ (work)
> 	$ git commit
760d598
< (((git commands, format-patch)))
762,763c600,601
< You use `git format-patch` to generate the mbox-formatted files that you can email to the list -- it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
< The nice thing about this is that applying a patch from an email generated with `format-patch` preserves all the commit information properly.
---
> You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list — it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
> The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly, as you’ll see more of in the next section when you apply these patches:
765,770c603,605
< [source,console]
< ----
< $ git format-patch -M origin/master
< 0001-add-limit-to-log-function.patch
< 0002-changed-log-output-to-30-from-25.patch
< ----
---
> 	$ git format-patch -M origin/master
> 	0001-add-limit-to-log-function.patch
> 	0002-changed-log-output-to-30-from-25.patch
776,782c611,615
< [source,console]
< ----
< $ cat 0001-add-limit-to-log-function.patch
< From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
< From: Jessica Smith <jessica@example.com>
< Date: Sun, 6 Apr 2008 10:17:23 -0700
< Subject: [PATCH 1/2] add limit to log function
---
> 	$ cat 0001-add-limit-to-log-function.patch
> 	From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
> 	From: Jessica Smith <jessica@example.com>
> 	Date: Sun, 6 Apr 2008 10:17:23 -0700
> 	Subject: [PATCH 1/2] add limit to log function
784c617
< Limit log functionality to the first 20
---
> 	Limit log functionality to the first 20
786c619
< ---
---
> 	---
790,794c623,627
< diff --git a/lib/simplegit.rb b/lib/simplegit.rb
< index 76f47bc..f9815f1 100644
< --- a/lib/simplegit.rb
< +++ b/lib/simplegit.rb
< @@ -14,7 +14,7 @@ class SimpleGit
---
> 	diff --git a/lib/simplegit.rb b/lib/simplegit.rb
> 	index 76f47bc..f9815f1 100644
> 	--- a/lib/simplegit.rb
> 	+++ b/lib/simplegit.rb
> 	@@ -14,7 +14,7 @@ class SimpleGit
798,799c631,632
< -    command("git log #{treeish}")
< +    command("git log -n 20 #{treeish}")
---
> 	-    command("git log #{treeish}")
> 	+    command("git log -n 20 #{treeish}")
803,805c636,637
< --
< 2.1.0
< ----
---
> 	--
> 	1.6.2.rc1.20.g8c5b.dirty
807,808c639,640
< You can also edit these patch files to add more information for the email list that you don't want to show up in the commit message.
< If you add text between the `---` line and the beginning of the patch (the `diff --git` line), the developers can read it, but that content is ignored by the patching process.
---
> You can also edit these patch files to add more information for the e-mail list that you don’t want to show up in the commit message.
> If you add text between the `---` line and the beginning of the patch (the `lib/simplegit.rb` line), then developers can read it; but applying the patch excludes it.
810,811c642,643
< To email this to a mailing list, you can either paste the file into your email program or send it via a command-line program.
< Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
---
> To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.
> Pasting the text often causes formatting issues, especially with "smarter" clients that don’t preserve newlines and other whitespace appropriately.
813c645
< We'll demonstrate how to send a patch via Gmail, which happens to be the email agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.
---
> I’ll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent I use; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.
815d646
< (((git commands, config)))(((email)))
817c648
< You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:
---
> You can set each value separately with a series of `git config` commands, or you can add them manually; but in the end, your config file should look something like this:
819,821c650
< [source,ini]
< ----
< [imap]
---
> 	[imap]
825c654
<   pass = YX]8g76G_2^sFbd
---
> 	  pass = p4ssw0rd
828d656
< ----
830c658
< If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
---
> If your IMAP server doesn’t use SSL, the last two lines probably aren’t necessary, and the host value will be `imap://` instead of `imaps://`.
833,841c661,666
< [source,console]
< ----
< $ cat *.patch |git imap-send
< Resolving imap.gmail.com... ok
< Connecting to [74.125.142.109]:993... ok
< Logging in...
< sending 2 messages
< 100% (2/2) done
< ----
---
> 	$ cat *.patch |git imap-send
> 	Resolving imap.gmail.com... ok
> 	Connecting to [74.125.142.109]:993... ok
> 	Logging in...
> 	sending 2 messages
> 	100% (2/2) done
843c668
< At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.
---
> At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you’re sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.
848,850c673
< [source,ini]
< ----
< [sendemail]
---
> 	[sendemail]
855d677
< ----
859,874c681,691
< [source,console]
< ----
< $ git send-email *.patch
< 0001-added-limit-to-log-function.patch
< 0002-changed-log-output-to-30-from-25.patch
< Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
< Emails will be sent from: Jessica Smith <jessica@example.com>
< Who should the emails be sent to? jessica@example.com
< Message-ID to be used as In-Reply-To for the first email? y
< ----
< 
< Then, Git spits out a bunch of log information looking something like this for each patch you're sending:
< 
< [source,text]
< ----
< (mbox) Adding cc: Jessica Smith <jessica@example.com> from
---
> 	$ git send-email *.patch
> 	0001-added-limit-to-log-function.patch
> 	0002-changed-log-output-to-30-from-25.patch
> 	Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
> 	Emails will be sent from: Jessica Smith <jessica@example.com>
> 	Who should the emails be sent to? jessica@example.com
> 	Message-ID to be used as In-Reply-To for the first email? y
> 
> Then, Git spits out a bunch of log information looking something like this for each patch you’re sending:
> 
> 	(mbox) Adding cc: Jessica Smith <jessica@example.com> from
876,901c693,715
< OK. Log says:
< Sendmail: /usr/sbin/sendmail -i jessica@example.com
< From: Jessica Smith <jessica@example.com>
< To: jessica@example.com
< Subject: [PATCH 1/2] added limit to log function
< Date: Sat, 30 May 2009 13:29:15 -0700
< Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
< X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
< In-Reply-To: <y>
< References: <y>
< 
< Result: OK
< ----
< 
< ==== Summary
< 
< This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
< Next, you'll see how to work the other side of the coin: maintaining a Git project.
< You'll learn how to be a benevolent dictator or integration manager.
< 
< 
< === Maintaining a Project
< 
< (((maintaining a project)))
< In addition to knowing how to contribute effectively to a project, you'll likely need to know how to maintain one.
< This can consist of accepting and applying patches generated via `format-patch` and emailed to you, or integrating changes in remote branches for repositories you've added as remotes to your project.
---
> 	OK. Log says:
> 	Sendmail: /usr/sbin/sendmail -i jessica@example.com
> 	From: Jessica Smith <jessica@example.com>
> 	To: jessica@example.com
> 	Subject: [PATCH 1/2] added limit to log function
> 	Date: Sat, 30 May 2009 13:29:15 -0700
> 	Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
> 	X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
> 	In-Reply-To: <y>
> 	References: <y>
> 
> 	Result: OK
> 
> ### Summary ###
> 
> This section has covered a number of common workflows for dealing with several very different types of Git projects you’re likely to encounter and introduced a couple of new tools to help you manage this process.
> Next, you’ll see how to work the other side of the coin: maintaining a Git project.
> You’ll learn how to be a benevolent dictator or integration manager.
> 
> ## Maintaining a Project ##
> 
> In addition to knowing how to effectively contribute to a project, you’ll likely need to know how to maintain one.
> This can consist of accepting and applying patches generated via `format-patch` and e-mailed to you, or integrating changes in remote branches for repositories you’ve added as remotes to your project.
904c718
< ==== Working in Topic Branches
---
> ### Working in Topic Branches ###
906,911c720,724
< (((branches, topic)))
< When you're thinking of integrating new work, it's generally a good idea to try it out in a _topic branch_ -- a temporary branch specifically made to try out that new work.
< This way, it's easy to tweak a patch individually and leave it if it's not working until you have time to come back to it.
< If you create a simple branch name based on the theme of the work you're going to try, such as `ruby_client` or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later.
< The maintainer of the Git project tends to namespace these branches as well -- such as `sc/ruby_client`, where `sc` is short for the person who contributed the work.
< As you'll remember, you can create the branch based off your `master` branch like this:
---
> When you’re thinking of integrating new work, it’s generally a good idea to try it out in a topic branch — a temporary branch specifically made to try out that new work.
> This way, it’s easy to tweak a patch individually and leave it if it’s not working until you have time to come back to it.
> If you create a simple branch name based on the theme of the work you’re going to try, such as `ruby_client` or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later.
> The maintainer of the Git project tends to namespace these branches as well — such as `sc/ruby_client`, where `sc` is short for the person who contributed the work.
> As you’ll remember, you can create the branch based off your master branch like this:
913,916c726
< [source,console]
< ----
< $ git branch sc/ruby_client master
< ----
---
> 	$ git branch sc/ruby_client master
918c728
< Or, if you want to also switch to it immediately, you can use the `checkout -b` option:
---
> Or, if you want to also switch to it immediately, you can use the `checkout -b` command:
920,923c730
< [source,console]
< ----
< $ git checkout -b sc/ruby_client master
< ----
---
> 	$ git checkout -b sc/ruby_client master
925c732
< Now you're ready to add the contributed work that you received into this topic branch and determine if you want to merge it into your longer-term branches.
---
> Now you’re ready to add your contributed work into this topic branch and determine if you want to merge it into your longer-term branches.
927,928c734
< [[_patches_from_email]]
< ==== Applying Patches from Email
---
> ### Applying Patches from E-mail ###
930,932c736,737
< (((email, applying patches from)))
< If you receive a patch over email that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it.
< There are two ways to apply an emailed patch: with `git apply` or with `git am`.
---
> If you receive a patch over e-mail that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it.
> There are two ways to apply an e-mailed patch: with `git apply` or with `git am`.
934c739
< ===== Applying a Patch with apply
---
> #### Applying a Patch with apply ####
936,937c741
< (((git commands, apply)))
< If you received the patch from someone who generated it with `git diff` or some variation of the Unix `diff` command (which is not recommended; see the next section), you can apply it with the `git apply` command.
---
> If you received the patch from someone who generated it with the `git diff` or a Unix `diff` command, you can apply it with the `git apply` command.
940,943c744
< [source,console]
< ----
< $ git apply /tmp/patch-ruby-client.patch
< ----
---
> 	$ git apply /tmp/patch-ruby-client.patch
946,959c747,757
< It's almost identical to running a `patch -p1` command to apply the patch, although it's more paranoid and accepts fewer fuzzy matches than patch.
< It also handles file adds, deletes, and renames if they're described in the `git diff` format, which `patch` won't do.
< Finally, `git apply` is an ``apply all or abort all'' model where either everything is applied or nothing is, whereas `patch` can partially apply patchfiles, leaving your working directory in a weird state.
< `git apply` is overall much more conservative than `patch`.
< It won't create a commit for you -- after running it, you must stage and commit the changes introduced manually.
< 
< You can also use `git apply` to see if a patch applies cleanly before you try actually applying it -- you can run `git apply --check` with the patch:
< 
< [source,console]
< ----
< $ git apply --check 0001-seeing-if-this-helps-the-gem.patch
< error: patch failed: ticgit.gemspec:1
< error: ticgit.gemspec: patch does not apply
< ----
---
> It’s almost identical to running a `patch -p1` command to apply the patch, although it’s more paranoid and accepts fewer fuzzy matches than patch.
> It also handles file adds, deletes, and renames if they’re described in the `git diff` format, which `patch` won’t do.
> Finally, `git apply` is an "apply all or abort all" model where either everything is applied or nothing is, whereas `patch` can partially apply patchfiles, leaving your working directory in a weird state.
> `git apply` is overall much more paranoid than `patch`.
> It won’t create a commit for you — after running it, you must stage and commit the changes introduced manually.
> 
> You can also use `git apply` to see if a patch applies cleanly before you try actually applying it — you can run `git apply --check` with the patch:
> 
> 	$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
> 	error: patch failed: ticgit.gemspec:1
> 	error: ticgit.gemspec: patch does not apply
964,965c762
< [[_git_am]]
< ===== Applying a Patch with `am`
---
> #### Applying a Patch with am ####
967d763
< (((git commands, am)))
972,973c768,769
< To apply a patch generated by `format-patch`, you use `git am` (the command is named `am` as it is used to "apply a series of patches from a mailbox").
< Technically, `git am` is built to read an mbox file, which is a simple, plain-text format for storing one or more email messages in one text file.
---
> To apply a patch generated by `format-patch`, you use `git am`.
> Technically, `git am` is built to read an mbox file, which is a simple, plain-text format for storing one or more e-mail messages in one text file.
976,996c772,787
< [source,console]
< ----
< From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
< From: Jessica Smith <jessica@example.com>
< Date: Sun, 6 Apr 2008 10:17:23 -0700
< Subject: [PATCH 1/2] add limit to log function
< 
< Limit log functionality to the first 20
< ----
< 
< This is the beginning of the output of the `git format-patch` command that you saw in the previous section; it also represents a valid mbox email format.
< If someone has emailed you the patch properly using `git send-email`, and you download that into an mbox format, then you can point `git am` to that mbox file, and it will start applying all the patches it sees.
< If you run a mail client that can save several emails out in mbox format, you can save entire patch series into a file and then use `git am` to apply them one at a time.
< 
< However, if someone uploaded a patch file generated via `git format-patch` to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to `git am` to apply it:
< 
< [source,console]
< ----
< $ git am 0001-limit-log-function.patch
< Applying: add limit to log function
< ----
---
> 	From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
> 	From: Jessica Smith <jessica@example.com>
> 	Date: Sun, 6 Apr 2008 10:17:23 -0700
> 	Subject: [PATCH 1/2] add limit to log function
> 
> 	Limit log functionality to the first 20
> 
> This is the beginning of the output of the format-patch command that you saw in the previous section.
> This is also a valid mbox e-mail format.
> If someone has e-mailed you the patch properly using `git send-email`, and you download that into an mbox format, then you can point `git am` to that mbox file, and it will start applying all the patches it sees.
> If you run a mail client that can save several e-mails out in mbox format, you can save entire patch series into a file and then use `git am` to apply them one at a time.
> 
> However, if someone uploaded a patch file generated via `format-patch` to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to `git am` to apply it:
> 
> 	$ git am 0001-limit-log-function.patch
> 	Applying: add limit to log function
999,1000c790,791
< The author information is taken from the email's `From` and `Date` headers, and the message of the commit is taken from the `Subject` and body (before the patch) of the email.
< For example, if this patch was applied from the mbox example above, the commit generated would look something like this:
---
> The author information is taken from the e-mail’s `From` and `Date` headers, and the message of the commit is taken from the `Subject` and body (before the patch) of the e-mail.
> For example, if this patch was applied from the mbox example I just showed, the commit generated would look something like this:
1002,1009c793,798
< [source,console]
< ----
< $ git log --pretty=fuller -1
< commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
< Author:     Jessica Smith <jessica@example.com>
< AuthorDate: Sun Apr 6 10:17:23 2008 -0700
< Commit:     Scott Chacon <schacon@gmail.com>
< CommitDate: Thu Apr 9 09:19:06 2009 -0700
---
> 	$ git log --pretty=fuller -1
> 	commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
> 	Author:     Jessica Smith <jessica@example.com>
> 	AuthorDate: Sun Apr 6 10:17:23 2008 -0700
> 	Commit:     Scott Chacon <schacon@gmail.com>
> 	CommitDate: Thu Apr 9 09:19:06 2009 -0700
1014d802
< ----
1019,1020c807,808
< But it's possible that the patch won't apply cleanly.
< Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven't applied yet.
---
> But it’s possible that the patch won’t apply cleanly.
> Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven’t applied yet.
1023,1033c811,818
< [source,console]
< ----
< $ git am 0001-seeing-if-this-helps-the-gem.patch
< Applying: seeing if this helps the gem
< error: patch failed: ticgit.gemspec:1
< error: ticgit.gemspec: patch does not apply
< Patch failed at 0001.
< When you have resolved this problem run "git am --resolved".
< If you would prefer to skip this patch, instead run "git am --skip".
< To restore the original branch and stop patching run "git am --abort".
< ----
---
> 	$ git am 0001-seeing-if-this-helps-the-gem.patch
> 	Applying: seeing if this helps the gem
> 	error: patch failed: ticgit.gemspec:1
> 	error: ticgit.gemspec: patch does not apply
> 	Patch failed at 0001.
> 	When you have resolved this problem run "git am --resolved".
> 	If you would prefer to skip this patch, instead run "git am --skip".
> 	To restore the original branch and stop patching run "git am --abort".
1036c821
< You solve this issue much the same way -- edit the file to resolve the conflict, stage the new file, and then run `git am --resolved` to continue to the next patch:
---
> You solve this issue much the same way — edit the file to resolve the conflict, stage the new file, and then run `git am --resolved` to continue to the next patch:
1038,1044c823,826
< [source,console]
< ----
< $ (fix the file)
< $ git add ticgit.gemspec
< $ git am --resolved
< Applying: seeing if this helps the gem
< ----
---
> 	$ (fix the file)
> 	$ git add ticgit.gemspec
> 	$ git am --resolved
> 	Applying: seeing if this helps the gem
1047,1048c829,830
< This option isn't on by default because it doesn't work if the commit the patch says it was based on isn't in your repository.
< If you do have that commit -- if the patch was based on a public commit -- then the `-3` option is generally much smarter about applying a conflicting patch:
---
> This option isn’t on by default because it doesn’t work if the commit the patch says it was based on isn’t in your repository.
> If you do have that commit — if the patch was based on a public commit — then the `-3` option is generally much smarter about applying a conflicting patch:
1050,1074c832,850
< [source,console]
< ----
< $ git am -3 0001-seeing-if-this-helps-the-gem.patch
< Applying: seeing if this helps the gem
< error: patch failed: ticgit.gemspec:1
< error: ticgit.gemspec: patch does not apply
< Using index info to reconstruct a base tree...
< Falling back to patching base and 3-way merge...
< No changes -- Patch already applied.
< ----
< 
< In this case, without the `-3` option the patch would have been considered as a conflict.
< Since the `-3` option was used the patch applied cleanly.
< 
< If you're applying a number of patches from an mbox, you can also run the `am` command in interactive mode, which stops at each patch it finds and asks if you want to apply it:
< 
< [source,console]
< ----
< $ git am -3 -i mbox
< Commit Body is:
< --------------------------
< seeing if this helps the gem
< --------------------------
< Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
< ----
---
> 	$ git am -3 0001-seeing-if-this-helps-the-gem.patch
> 	Applying: seeing if this helps the gem
> 	error: patch failed: ticgit.gemspec:1
> 	error: ticgit.gemspec: patch does not apply
> 	Using index info to reconstruct a base tree...
> 	Falling back to patching base and 3-way merge...
> 	No changes -- Patch already applied.
> 
> In this case, I was trying to apply a patch I had already applied.
> Without the `-3` option, it looks like a conflict.
> 
> If you’re applying a number of patches from an mbox, you can also run the `am` command in interactive mode, which stops at each patch it finds and asks if you want to apply it:
> 
> 	$ git am -3 -i mbox
> 	Commit Body is:
> 	--------------------------
> 	seeing if this helps the gem
> 	--------------------------
> 	Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
1076c852
< This is nice if you have a number of patches saved, because you can view the patch first if you don't remember what it is, or not apply the patch if you've already done so.
---
> This is nice if you have a number of patches saved, because you can view the patch first if you don’t remember what it is, or not apply the patch if you’ve already done so.
1080,1081c856
< [[_checking_out_remotes]]
< ==== Checking Out Remote Branches
---
> ### Checking Out Remote Branches ###
1083d857
< (((branches, remote)))
1086c860
< For instance, if Jessica sends you an email saying that she has a great new feature in the `ruby-client` branch of her repository, you can test it by adding the remote and checking out that branch locally:
---
> For instance, if Jessica sends you an e-mail saying that she has a great new feature in the `ruby-client` branch of her repository, you can test it by adding the remote and checking out that branch locally:
1088,1100c862,871
< [source,console]
< ----
< $ git remote add jessica git://github.com/jessica/myproject.git
< $ git fetch jessica
< $ git checkout -b rubyclient jessica/ruby-client
< ----
< 
< If she emails you again later with another branch containing another great feature, you could directly `fetch` and `checkout` because you already have the remote setup.
< 
< This is most useful if you're working with a person consistently.
< If someone only has a single patch to contribute once in a while, then accepting it over email may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches.
< You're also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two.
< However, scripts and hosted services may make this easier -- it depends largely on how you develop and how your contributors develop.
---
> 	$ git remote add jessica git://github.com/jessica/myproject.git
> 	$ git fetch jessica
> 	$ git checkout -b rubyclient jessica/ruby-client
> 
> If she e-mails you again later with another branch containing another great feature, you can fetch and check out because you already have the remote setup.
> 
> This is most useful if you’re working with a person consistently.
> If someone only has a single patch to contribute once in a while, then accepting it over e-mail may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches.
> You’re also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two.
> However, scripts and hosted services may make this easier — it depends largely on how you develop and how your contributors develop.
1105,1106c876,877
< If you aren't working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the `git pull` command.
< This does a one-time pull and doesn't save the URL as a remote reference:
---
> If you aren’t working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the `git pull` command.
> This does a one-time pull and doesn’t save the URL as a remote reference:
1108,1111c879,880
< [source,console]
< ----
< $ git pull https://github.com/onetimeguy/project
< From https://github.com/onetimeguy/project
---
> 	$ git pull git://github.com/onetimeguy/project.git
> 	From git://github.com/onetimeguy/project
1113,1114c882
< Merge made by the 'recursive' strategy.
< ----
---
> 	Merge made by recursive.
1116,1117c884
< [[_what_is_introduced]]
< ==== Determining What Is Introduced
---
> ### Determining What Is Introduced ###
1119d885
< (((branches, diffing)))
1121,1122c887,888
< At this point, you can determine what you'd like to do with it.
< This section revisits a couple of commands so you can see how you can use them to review exactly what you'll be introducing if you merge this into your main branch.
---
> At this point, you can determine what you’d like to do with it.
> This section revisits a couple of commands so you can see how you can use them to review exactly what you’ll be introducing if you merge this into your main branch.
1124c890
< It's often helpful to get a review of all the commits that are in this branch but that aren't in your master branch.
---
> It’s often helpful to get a review of all the commits that are in this branch but that aren’t in your master branch.
1126d891
< This does the same thing as the `master..contrib` format that we used earlier.
1129,1134c894,897
< [source,console]
< ----
< $ git log contrib --not master
< commit 5b6235bd297351589efc4d73316f0a68d484f118
< Author: Scott Chacon <schacon@gmail.com>
< Date:   Fri Oct 24 09:53:59 2008 -0700
---
> 	$ git log contrib --not master
> 	commit 5b6235bd297351589efc4d73316f0a68d484f118
> 	Author: Scott Chacon <schacon@gmail.com>
> 	Date:   Fri Oct 24 09:53:59 2008 -0700
1138,1140c901,903
< commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
< Author: Scott Chacon <schacon@gmail.com>
< Date:   Mon Oct 22 19:38:36 2008 -0700
---
> 	commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
> 	Author: Scott Chacon <schacon@gmail.com>
> 	Date:   Mon Oct 22 19:38:36 2008 -0700
1143d905
< ----
1150,1153c912
< [source,console]
< ----
< $ git diff master
< ----
---
> 	$ git diff master
1156,1158c915,917
< If your `master` branch has moved forward since you created the topic branch from it, then you'll get seemingly strange results.
< This happens because Git directly compares the snapshots of the last commit of the topic branch you're on and the snapshot of the last commit on the `master` branch.
< For example, if you've added a line in a file on the `master` branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.
---
> If your `master` branch has moved forward since you created the topic branch from it, then you’ll get seemingly strange results.
> This happens because Git directly compares the snapshots of the last commit of the topic branch you’re on and the snapshot of the last commit on the `master` branch.
> For example, if you’ve added a line in a file on the `master` branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.
1160c919
< If `master` is a direct ancestor of your topic branch, this isn't a problem; but if the two histories have diverged, the diff will look like you're adding all the new stuff in your topic branch and removing everything unique to the `master` branch.
---
> If `master` is a direct ancestor of your topic branch, this isn’t a problem; but if the two histories have diverged, the diff will look like you’re adding all the new stuff in your topic branch and removing everything unique to the `master` branch.
1162c921
< What you really want to see are the changes added to the topic branch -- the work you'll introduce if you merge this branch with master.
---
> What you really want to see are the changes added to the topic branch — the work you’ll introduce if you merge this branch with master.
1167,1187c926,933
< [source,console]
< ----
< $ git merge-base contrib master
< 36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
< $ git diff 36c7db
< ----
< 
< or, more concisely:
< 
< [source,console]
< ----
< $ git diff $(git merge-base contrib master)
< ----
< 
< However, neither of those is particularly convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax.
< In the context of the `git diff` command, you can put three periods after another branch to do a `diff` between the last commit of the branch you're on and its common ancestor with another branch:
< 
< [source,console]
< ----
< $ git diff master...contrib
< ----
---
> 	$ git merge-base contrib master
> 	36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
> 	$ git diff 36c7db
> 
> However, that isn’t convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax.
> In the context of the `diff` command, you can put three periods after another branch to do a `diff` between the last commit of the branch you’re on and its common ancestor with another branch:
> 
> 	$ git diff master...contrib
1192c938
< ==== Integrating Contributed Work
---
> ### Integrating Contributed Work ###
1194d939
< (((integrating work)))
1196,1197c941
< Furthermore, what overall workflow do you want to use to maintain your project?
< You have a number of choices, so we'll cover a few of them.
---
> Furthermore, what overall workflow do you want to use to maintain your project? You have a number of choices, so I’ll cover a few of them.
1199c943
< ===== Merging Workflows
---
> #### Merging Workflows ####
1201,1202c945
< (((workflows, merging)))
< One basic workflow is to simply merge all that work directly into your `master` branch.
---
> One simple workflow merges your work into your `master` branch.
1204,1206c947,948
< When you have work in a topic branch that you think you've completed, or work that someone else has contributed and you've verified, you merge it into your master branch, delete that just-merged topic branch, and repeat.
< 
< For instance, if we have a repository with work in two branches named `ruby_client` and `php_client` that looks like <<merwf_a>>, and we merge `ruby_client` followed by `php_client`, your history will end up looking like <<merwf_b>>.
---
> When you have work in a topic branch that you’ve done or that someone has contributed and you’ve verified, you merge it into your master branch, delete the topic branch, and then continue the process.
>  If we have a repository with work in two branches named `ruby_client` and `php_client` that looks like Figure 5-19 and merge `ruby_client` first and then `php_client` next, then your history will end up looking like Figure 5-20.
1208,1210c950,951
< [[merwf_a]]
< .History with several topic branches.
< image::images/merging-workflows-1.png[History with several topic branches.]
---
> Insert 18333fig0519.png
> Figure 5-19. History with several topic branches.
1212,1214c953,954
< [[merwf_b]]
< .After a topic branch merge.
< image::images/merging-workflows-2.png[After a topic branch merge.]
---
> Insert 18333fig0520.png
> Figure 5-20. After a topic branch merge.
1216c956
< That is probably the simplest workflow, but it can possibly be problematic if you're dealing with larger or more stable projects where you want to be really careful about what you introduce.
---
> That is probably the simplest workflow, but it’s problematic if you’re dealing with larger repositories or projects.
1218c958
< If you have a more important project, you might want to use a two-phase merge cycle.
---
> If you have more developers or a larger project, you’ll probably want to use at least a two-phase merge cycle.
1221c961
< Each time you have a new topic branch to merge in (<<merwf_c>>), you merge it into `develop` (<<merwf_d>>); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (<<merwf_e>>).
---
> Each time you have a new topic branch to merge in (Figure 5-21), you merge it into `develop` (Figure 5-22); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (Figure 5-23).
1223,1225c963,964
< [[merwf_c]]
< .Before a topic branch merge.
< image::images/merging-workflows-3.png[Before a topic branch merge.]
---
> Insert 18333fig0521.png
> Figure 5-21. Before a topic branch merge.
1227,1229c966,967
< [[merwf_d]]
< .After a topic branch merge.
< image::images/merging-workflows-4.png[After a topic branch merge.]
---
> Insert 18333fig0522.png
> Figure 5-22. After a topic branch merge.
1231,1233c969,970
< [[merwf_e]]
< .After a project release.
< image::images/merging-workflows-5.png[After a topic branch release.]
---
> Insert 18333fig0523.png
> Figure 5-23. After a topic branch release.
1235,1237c972,974
< This way, when people clone your project's repository, they can either check out `master` to build the latest stable version and keep up to date on that easily, or they can check out `develop`, which is the more cutting-edge content.
< You can also extend this concept by having an `integrate` branch where all the work is merged together.
< Then, when the codebase on that branch is stable and passes tests, you merge it into a `develop` branch; and when that has proven itself stable for a while, you fast-forward your `master` branch.
---
> This way, when people clone your project’s repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff.
> You can also continue this concept, having an integrate branch where all the work is merged together.
> Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.
1239c976
< ===== Large-Merging Workflows
---
> #### Large-Merging Workflows ####
1241d977
< (((workflows, "merging (large)")))
1243,1254c979,981
< When new work is introduced by contributors, it's collected into topic branches in the maintainer's repository in a manner similar to what we've described (see <<merwf_f>>).
< At this point, the topics are evaluated to determine whether they're safe and ready for consumption or whether they need more work.
< If they're safe, they're merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.
< 
< [[merwf_f]]
< .Managing a complex series of parallel contributed topic branches.
< image::images/large-merges-1.png[Managing a complex series of parallel contributed topic branches.]
< 
< If the topics still need work, they're merged into `pu` instead.
< When it's determined that they're totally stable, the topics are re-merged into `master`.
< The `next` and `pu` branches are then rebuilt from the `master`.
< This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often:
---
> When new work is introduced by contributors, it’s collected into topic branches in the maintainer’s repository in a manner similar to what I’ve described (see Figure 5-24).
> At this point, the topics are evaluated to determine whether they’re safe and ready for consumption or whether they need more work.
> If they’re safe, they’re merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.
1256,1257c983,984
< .Merging contributed topic branches into long-term integration branches.
< image::images/large-merges-2.png[Merging contributed topic branches into long-term integration branches.]
---
> Insert 18333fig0524.png
> Figure 5-24. Managing a complex series of parallel contributed topic branches.
1259c986,993
< When a topic branch has finally been merged into `master`, it's removed from the repository.
---
> If the topics still need work, they’re merged into `pu` instead.
> When it’s determined that they’re totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn’t yet graduate to `master`.
> This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often (see Figure 5-25).
> 
> Insert 18333fig0525.png
> Figure 5-25. Merging contributed topic branches into long-term integration branches.
> 
> When a topic branch has finally been merged into `master`, it’s removed from the repository.
1262,1263d995
< The Git project's workflow is specialized.
< To clearly understand this you could check out the https://github.com/git/git/blob/master/Documentation/howto/maintain-git.txt[Git Maintainer's guide].
1265,1266c997
< [[_rebase_cherry_pick]]
< ===== Rebasing and Cherry-Picking Workflows
---
> #### Rebasing and Cherry Picking Workflows ####
1268d998
< (((workflows, rebasing and cherry-picking)))
1271c1001
< If that works well, you can fast-forward your `master` branch, and you'll end up with a linear project history.
---
> If that works well, you can fast-forward your `master` branch, and you’ll end up with a linear project history.
1273d1002
< (((git commands, cherry-pick)))
1276,1278c1005,1007
< It takes the patch that was introduced in a commit and tries to reapply it on the branch you're currently on.
< This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you'd prefer to cherry-pick it rather than run rebase.
< For example, suppose you have a project that looks like this:
---
> It takes the patch that was introduced in a commit and tries to reapply it on the branch you’re currently on.
> This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you’d prefer to cherry-pick it rather than run rebase.
> For example, suppose you have a project that looks like Figure 5-26.
1280,1281c1009,1010
< .Example history before a cherry-pick.
< image::images/rebasing-1.png[Example history before a cherry-pick.]
---
> Insert 18333fig0526.png
> Figure 5-26. Example history before a cherry pick.
1285,1289c1014,1016
< [source,console]
< ----
< $ git cherry-pick e43a6
< Finished one cherry-pick.
< [master]: created a0a41a9: "More friendly message when locking the index fails."
---
> 	$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
> 	Finished one cherry-pick.
> 	[master]: created a0a41a9: "More friendly message when locking the index fails."
1291,1304d1017
< ----
< 
< This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different.
< Now your history looks like this:
< 
< .History after cherry-picking a commit on a topic branch.
< image::images/rebasing-2.png[History after cherry-picking a commit on a topic branch.]
< 
< Now you can remove your topic branch and drop the commits you didn't want to pull in.
< 
< ===== Rerere
< 
< (((git commands, rerere)))(((rerere)))
< If you're doing lots of merging and rebasing, or you're maintaining a long-lived topic branch, Git has a feature called ``rerere'' that can help.
1306,1307c1019
< Rerere stands for ``reuse recorded resolution'' -- it's a way of shortcutting manual conflict resolution.
< When rerere is enabled, Git will keep a set of pre- and post-images from successful merges, and if it notices that there's a conflict that looks exactly like one you've already fixed, it'll just use the fix from last time, without bothering you with it.
---
> This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different. Now your history looks like Figure 5-27.
1309,1310c1021,1022
< This feature comes in two parts: a configuration setting and a command.
< The configuration setting is `rerere.enabled`, and it's handy enough to put in your global config:
---
> Insert 18333fig0527.png
> Figure 5-27. History after cherry-picking a commit on a topic branch.
1312,1315c1024
< [source,console]
< ----
< $ git config --global rerere.enabled true
< ----
---
> Now you can remove your topic branch and drop the commits you didn’t want to pull in.
1317c1026
< Now, whenever you do a merge that resolves conflicts, the resolution will be recorded in the cache in case you need it in the future.
---
> ### Tagging Your Releases ###
1319,1329c1028,1029
< If you need to, you can interact with the rerere cache using the `git rerere` command.
< When it's invoked alone, Git checks its database of resolutions and tries to find a match with any current merge conflicts and resolve them (although this is done automatically if `rerere.enabled` is set to `true`).
< There are also subcommands to see what will be recorded, to erase specific resolution from the cache, and to clear the entire cache.
< We will cover rerere in more detail in <<ch07-git-tools#ref_rerere>>.
< 
< [[_tagging_releases]]
< ==== Tagging Your Releases
< 
< (((tags)))(((tags, signing)))
< When you've decided to cut a release, you'll probably want to assign a tag so you can re-create that release at any point going forward.
< You can create a new tag as discussed in <<ch02-git-basics-chapter#ch02-git-basics-chapter>>.
---
> When you’ve decided to cut a release, you’ll probably want to drop a tag so you can re-create that release at any point going forward.
> You can create a new tag as I discussed in Chapter 2.
1332,1338c1032,1035
< [source,console]
< ----
< $ git tag -s v1.5 -m 'my signed 1.5 tag'
< You need a passphrase to unlock the secret key for
< user: "Scott Chacon <schacon@gmail.com>"
< 1024-bit DSA key, ID F721C45A, created 2009-02-09
< ----
---
> 	$ git tag -s v1.5 -m 'my signed 1.5 tag'
> 	You need a passphrase to unlock the secret key for
> 	user: "Scott Chacon <schacon@gmail.com>"
> 	1024-bit DSA key, ID F721C45A, created 2009-02-09
1344,1352c1041,1046
< [source,console]
< ----
< $ gpg --list-keys
< /Users/schacon/.gnupg/pubring.gpg
< ---------------------------------
< pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
< uid                  Scott Chacon <schacon@gmail.com>
< sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
< ----
---
> 	$ gpg --list-keys
> 	/Users/schacon/.gnupg/pubring.gpg
> 	---------------------------------
> 	pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
> 	uid                  Scott Chacon <schacon@gmail.com>
> 	sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
1356,1360c1050,1051
< [source,console]
< ----
< $ gpg -a --export F721C45A | git hash-object -w --stdin
< 659ef797d181633c87ec71ac3f9ba29fe5775b92
< ----
---
> 	$ gpg -a --export F721C45A | git hash-object -w --stdin
> 	659ef797d181633c87ec71ac3f9ba29fe5775b92
1364,1367c1055
< [source,console]
< ----
< $ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
< ----
---
> 	$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
1372,1375c1060
< [source,console]
< ----
< $ git show maintainer-pgp-pub | gpg --import
< ----
---
> 	$ git show maintainer-pgp-pub | gpg --import
1380,1381c1065,1068
< [[_build_number]]
< ==== Generating a Build Number
---
> ### Generating a Build Number ###
> 
> Because Git doesn’t have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
> Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you’re describing:
1383,1391c1070,1071
< (((build numbers)))(((git commands, describe)))
< Because Git doesn't have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
< In response, Git generates a string consisting of the name of the most recent tag earlier than that commit, followed by the number of commits since that tag, followed finally by a partial SHA-1 value of the commit being described (prefixed with the letter "g" meaning Git):
< 
< [source,console]
< ----
< $ git describe master
< v1.6.2-rc1-20-g8c5b85c
< ----
---
> 	$ git describe master
> 	v1.6.2-rc1-20-g8c5b85c
1395c1075
< If you're describing a commit that you have directly tagged, it gives you simply the tag name.
---
> If you’re describing a commit that you have directly tagged, it gives you the tag name.
1397,1398c1077,1078
< By default, the `git describe` command requires annotated tags (tags created with the `-a` or `-s` flag); if you want to take advantage of lightweight (non-annotated) tags as well, add the `--tags` option to the command.
< You can also use this string as the target of a `git checkout` or `git show` command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
---
> The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you’re using `git describe`, to ensure the commit is named properly when described.
> You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
1401,1402c1081
< [[_preparing_release]]
< ==== Preparing a Release
---
> ### Preparing a Release ###
1404d1082
< (((releasing)))(((git commands, archive)))
1406c1084
< One of the things you'll want to do is create an archive of the latest snapshot of your code for those poor souls who don't use Git.
---
> One of the things you’ll want to do is create an archive of the latest snapshot of your code for those poor souls who don’t use Git.
1409,1414c1087,1089
< [source,console]
< ----
< $ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
< $ ls *.tar.gz
< v1.6.2-rc1-20-g8c5b85c.tar.gz
< ----
---
> 	$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
> 	$ ls *.tar.gz
> 	v1.6.2-rc1-20-g8c5b85c.tar.gz
1419,1431c1094,1101
< [source,console]
< ----
< $ git archive master --prefix='project/' --format=zip > `git describe master`.zip
< ----
< 
< You now have a nice tarball and a zip archive of your project release that you can upload to your website or email to people.
< 
< [[_the_shortlog]]
< ==== The Shortlog
< 
< (((git commands, shortlog)))
< It's time to email your mailing list of people who want to know what's happening in your project.
< A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or email is to use the `git shortlog` command.
---
> 	$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
> 
> You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.
> 
> ### The Shortlog ###
> 
> It’s time to e-mail your mailing list of people who want to know what’s happening in your project.
> A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the `git shortlog` command.
1434,1437c1104,1105
< [source,console]
< ----
< $ git shortlog --no-merges master --not v1.0.1
< Chris Wanstrath (6):
---
> 	$ git shortlog --no-merges master --not v1.0.1
> 	Chris Wanstrath (8):
1445c1113
< Tom Preston-Werner (4):
---
> 	Tom Preston-Werner (4):
1450d1117
< ----
1452c1119
< You get a clean summary of all the commits since v1.0.1, grouped by author, that you can email to your list.
---
> You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.
1454c1121
< === Summary
---
> ## Summary ##
1456,1458c1123,1124
< You should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or integrating other users' contributions.
< Congratulations on being an effective Git developer!
< In the next chapter, you'll learn about how to use the largest and most popular Git hosting service, GitHub.
---
> You should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or integrating other users’ contributions.
> Congratulations on being an effective Git developer! In the next chapter, you’ll learn more powerful tools and tips for dealing with complex situations, which will truly make you a Git master.
